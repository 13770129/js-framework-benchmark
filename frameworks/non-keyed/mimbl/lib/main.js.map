{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///webpack://mimbl/webpack/universalModuleDefinition","webpack:///webpack://mimbl/webpack/bootstrap","webpack:///webpack://mimbl/src/api/mim.ts","webpack:///webpack://mimbl/src/core/VN.ts","webpack:///webpack://mimbl/src/core/VNBase.ts","webpack:///webpack://mimbl/src/core/ContentFuncs.ts","webpack:///webpack://mimbl/src/core/Scheduler.ts","webpack:///webpack://mimbl/src/core/ClassCompVN.ts","webpack:///webpack://mimbl/src/utils/ElmAttr.ts","webpack:///webpack://mimbl/src/utils/Utils.ts","webpack:///webpack://mimbl/src/mimblTypes.ts","webpack:///webpack://mimbl/src/utils/EventSlot.ts","webpack:///webpack://mimbl/src/core/VNDisp.ts","webpack:///webpack://mimbl/src/core/PubSub.ts","webpack:///webpack://mimbl/src/core/IndependentCompVN.ts","webpack:///webpack://mimbl/src/core/ManagedCompVN.ts","webpack:///webpack://mimbl/src/core/FuncVN.ts","webpack:///webpack://mimbl/src/core/ElmVN.ts","webpack:///webpack://mimbl/src/utils/SvgElms.ts","webpack:///webpack://mimbl/src/core/TextVN.ts","webpack:///webpack://mimbl/src/core/RootVN.ts","webpack:///webpack://mimbl/src/core/RootUI.tsx","webpack:///webpack://mimbl/src/api/LocalStyles.ts","webpack:///./src/Main.tsx","webpack:///./src/Store.js","webpack:///./src/TBody.tsx","webpack:///./src/Row.tsx"],"names":["root","factory","exports","module","define","amd","a","i","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Component","props","vn","requestUpdate","func","beforeUpdate","scheduleCall","listener","initialReferene","changedEvent","EventSlot","add","_r","remove","newRef","fire","clear","ref","val","onlyIf","refObj","target","attrName","super","update","promise","progressContent","errorContentFunc","content","watchPromise","err","anotherErr","elm","ownerSVGElement","tag","children","createNodesFromJSX","anchorDN","mountRootSync","unmountRootSync","mountRoot","unmountRoot","handlerClass","ElmAttr","registerProperty","type","slices","utils","mergeSlices","resSlice","mergeSlicesTo","classNames","mergeClasses","styles","mergeStyles","resStyle","mergeStylesTo","VNUpdateDisp","shouldCommit","shouldRender","DoCommitDoRender","DoCommitNoRender","NoCommitDoRender","NoCommitNoRender","getLastDN","ownDN","subNodes","dn","length","getFirstDN","svn","arr","collectImmediateDNs","push","getNextDNUnderSameAnchorDN","nextSibling","nvn","next","parent","depth","path","Array","CallbackWrapper","that","orgCallback","rest","arguments","apply","errorService","findService","reportError","getVNPath","publishedServices","forEach","service","id","notifyServiceUnpublished","subscribedServices","info","notifyServiceUnsubscribed","prev","keyedSubNodes","updateRequested","requestNodeUpdate","scheduleFuncCall","Map","set","notifyServicePublished","delete","size","defaultService","useSelf","VNSubscribedServiceInfo","notifyServiceSubscribed","mim","setRef","getService","callback","createNodesFromContent","TextVN","VNBase","render","IndependentCompVN","isArray","createNodesFromArray","Promise","toString","nodes","item","itemNodes","ElmVN","Fragment","realChildren","ManagedCompVN","FuncVN","SchedulerState","Idle","BeforeUpdate","Update","AfterUpdate","s_vnsScheduledForUpdate","Set","s_callsScheduledBeforeUpdate","s_callsScheduledAfterUpdate","s_scheduledFrameHandle","s_schedulerState","s_currentTick","requestFrameIfNeeded","requestAnimationFrame","onScheduledFrame","s_currentVN","vns","performCommitPhase","performRenderPhase","console","warn","join","callsScheduledBeforeUpdate","callScheduledFunctions","vnsScheduledForUpdate","vnsByDepth","callsScheduledAfterUpdate","disp","updatedNodeDisps","lastUpdateTick","updateVirtual","VNDisp","undefined","updatePhysical","subNodesToRemove","destroyPhysical","oldVN","beforeDN","subNodeDisps","subNodeGroups","parentVN","disps","groups","nextVN","newVN","firstDN","currSubNodeIndex","group","j","last","first","action","updateDisp","commitUpdate","createPhysical","determineDNs","prevGroup","lastDN","count","moveGroup","subNodeDNs","getImmediateDNs","subNodeDN","insertBefore","funcs","beforeOrAfter","error","createVirtual","init","currentVN","willMount","supportsErrorHandling","handleError","createSubNodesVirtual","createVNChainFromContent","prevVN","mount","newAnchorDN","newBeforeDN","preDestroy","willUnmount","message","unmount","term","updateSubNodesVirtual","buildSubNodeDispositions","subNodeDisp","prepareUpdate","subNodeVN","comp","getUpdateStrategy","propName","propInfos","propVal","setAttribute","oldPropVal","newPropVal","updateVal","diff","removeAttribute","setValueProp","diffDefaultValueProp","oldPropValVal","removeDefaultValueProp","setCheckedProp","checked","elmStyle","style","keyVal","oldStyle","newStyle","changesExist","oldVal","newVal","isBubbling","hashString","len","h","charCodeAt","resClassName","className","styleObj","parseStyleString","retStyle","elms","split","pair","dashToCamel","trim","dash","camel","index","nextIndexToCopyFrom","indexOf","substr","toUpperCase","slice","oldContent","deepCompare","o1","o2","hashObject","isNaN","realFire","listeners","event","eventFunc","slots","slot","VNDispGroup","parentDisp","NO_GROUP_THRESHOLD","newChain","newLen","oldChain","oldLen","map","allowKeyedNodeRecycling","updateStrategy","isUpdatePossible","oldMap","oldMapSize","matchOldNonKeyedOnly","matchOldMixed","matchOldKeyedOnly","buildGroups","buildSubNodeGroups","newUnmatchedDisps","iOld","iNew","newUnmatchedLen","has","ServiceInfo","publishingVNs","subscribedVNs","s_serviceInfos","sourceVN","notifyServiceChanged","ClassCompVN","getDisplayName","constructor","willMountInstance","willUnmountInstance","newComp","needsUpdating","getStockValue","compClass","newClassVN","shouldUpdate","keys","assign","newFuncVN","isEventValue","getPropAsEventRunTimeData","orgFunc","useCapture","tagName","elmName","creator","svgInfo","SvgElms","getSvgElmInfo","isSvg","namespaceURI","endsWith","document","createElementNS","namespace","getElmName","createElement","parseProps","attrs","addAttrs","events","addEvents","customAttrs","addCustomAttrs","removeCustomAttrs","newElmVN","updateAttrs","updateEvents","updateCustomAttrs","propInfo","propType","getPropertyInfo","eventInfo","handler","rtd","setAttr","newAttrs","oldAttrs","oldRTD","newRTD","updateAttr","removeAttr","addEvent","wrapper","createEventWrapper","addEventListener","removeEventListener","newEvents","oldEvents","oldEvent","newEvent","updateEvent","removeEvent","wrapCallback","customAttr","isRemoval","terminate","newCustomAttrs","oldCustomAttrs","oldCustomAttr","newCustomAttr","infos","isDualPurpose","svg","animate","animateMotion","animateTransform","circle","clipPath","colorProfile","defs","desc","discard","ellipse","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","filter","foreignObject","g","hatch","hatchpath","image","line","linearGradient","marker","mask","metadata","mpath","pattern","polygon","polyline","radialGradient","rect","script","solidcolor","stop","switch","symbol","text","textPath","title","textSpan","use","view","textNode","createTextNode","nodeValue","RootVN","thrownPromises","sync","updateNodeSync","errorUI","waitingUI","publishService","unpublishService","then","onPromiseFulfilled","catch","RootWaitingUI","RootErrorUI","s_mimblAnchorPropName","realAnchorDN","body","rootVN","setContent","onRestart","restart","pathString","display","flexDirection","alignItems","width","click","m_uniqueID","Math","floor","random","rules","ruleNames","styleElm","head","appendChild","selector","createDummyRule","cssomRule","mcssStyleRule","MCssStyleRule","uniqueID","setSelector","setProperties","mcssRule","ruleText","removeRule","sheet","insertRule","MCssRuleBase","replace","selectorText","important","setProperty","removeProperty","Main","store","Store","tbody","TBody","window","app","run","runLots","updateMe","swapRows","row","onSelectRowClicked","onDeleteRowClicked","class","getElementById","_random","max","round","data","selected","adjectives","colours","nouns","label","mod","idx","findIndex","splice","buildData","newData","concat","updateData","main","rows","selectedRow","Row","setItem","tempRow","select","newLabel","newSelectedID","onSelectClicked","onDeleteClicked","updatable"],"mappings":"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","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mimbl\"] = factory();\n\telse\n\t\troot[\"mimbl\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","/**\r\n * Type used to define properties that can be passed to a functional component.\r\n * \r\n * @typeparam TProps Type defining properties that can be passed to the functional component\r\n *\t\twith these properties. Default type is an empty object (no properties).\r\n * @typeparam TChildren Type defining components, elements or other objects that can be used\r\n *\t\tas children for the functional component with these properties. Default is `any`.\r\n */\r\nexport type FuncProps<TProps = {}, TChildren = any> = Readonly<TProps> &\r\n\t{\r\n\t\treadonly children?: TChildren;\r\n\t};\r\n\r\n\r\n\r\n/**\r\n * Type of functions representing functional components.\r\n * \r\n * @typeparam TProps Type defining properties that can be passed to this functional component.\r\n *\t\tDefault type is an empty object (no properties).\r\n * @typeparam TChildren Type defining components, elements or other objects that can be used\r\n *\t\tas children for this functional component. Default is `any`.\r\n */\r\nexport type FuncCompType<TProps = {}, TChildren = any> = (props: FuncProps<TProps,TChildren>) => any;\r\n\r\n\r\n\r\n/**\r\n * Type used to define properties that can be passed to a class-based component.\r\n * \r\n * @typeparam TProps Type defining properties that can be passed to the class-based component\r\n *\t\twith these properties. Default type is an empty object (no properties).\r\n * @typeparam TChildren Type defining components, elements or other objects that can be used\r\n *\t\tas children for the class-based component with these properties. Default is `any`.\r\n */\r\nexport type CompProps<TProps = {}, TChildren = any> = Readonly<TProps> &\r\n\t{\r\n\t\treadonly children?: TChildren;\r\n\t};\r\n\r\n\r\n\r\n/**\r\n * Interface that defines constructor signature for components.\r\n * \r\n * @typeparam TProps Type defining properties that can be passed to the class-based component\r\n *\t\tof this type. Default type is an empty object (no properties).\r\n * @typeparam TChildren Type defining components, elements or other objects that can be used\r\n *\t\tas children for the class-based component of this type. Default is `any`.\r\n */\r\nexport interface IComponentClass<TProps = {}, TChildren = any>\r\n{\r\n\tnew( props?: TProps): IComponent<TProps,TChildren>;\r\n\trender(): any;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Interface that must be implemented by all components.\r\n * \r\n * @typeparam TProps Type defining properties that can be passed to this class-based component.\r\n *\t\tDefault type is an empty object (no properties).\r\n * @typeparam TChildren Type defining components, elements or other objects that can be used\r\n *\t\tas children for this class-based component. Default is `any`.\r\n */\r\nexport interface IComponent<TProps = {}, TChildren = any>\r\n{\r\n\t/** Component properties passed to the constructor */\r\n\tprops: CompProps<TProps,TChildren>;\r\n\r\n\t/**\r\n\t * Components can define display name for tracing purposes; if they don't the default name\r\n\t * is the component's class constructor name. Note that this method can be called before\r\n\t * the virtual node is attached to the component.\r\n\t */\r\n\tgetDisplayName?(): string;\r\n\r\n\t/**\r\n\t * Sets, gets or clears the virtual node object of the component. This property is set twice:\r\n\t *  1. Before the component is rendered for the first time: the component must remember the\r\n\t *    passed object.\r\n\t *  2. Before the component is destroyed: null is passed as a parameter and the component must\r\n\t *    release the remembered object.\r\n\t */\r\n\tvn?: IVNode;\r\n\r\n\t/**\r\n\t * Notifies that the component is about to render its content for the first time. This method\r\n\t * is called when the virtual node has already been set so the component can request services\r\n\t * from it.\r\n\t */\r\n\twillMount?(): void;\r\n\r\n\t/** Returns the component's content that will be ultimately placed into the DOM tree. */\r\n\trender(): any;\r\n\r\n\t/**\r\n\t * Informs the component that new properties have been specified. At the time of the call\r\n\t * this.props refers to the \"old\" properties. If the component returns true,then its render\r\n\t * method will be called. At that time,the original props object that was passed into the\r\n\t * component's constructor will have these new properties. If the component doesn't implement\r\n\t * the shouldUpdate method it is as though true is returned. If the component returns\r\n\t * false, the render method is not called and the DOM tree of the component remains unchanged.\r\n\t * The properties of the component, however, still change.\r\n\t * @param newProps The new properties that the parent component provides to this component.\r\n\t * @returns True if the component should have its render method called and false otherwise.\r\n\t */\r\n\tshouldUpdate?( newProps: CompProps<TProps,TChildren>): boolean;\r\n\r\n\t/**\r\n\t * Notifies that the component's content is going to be removed from the DOM tree. After\r\n\t * this method returns the component is destroyed.\r\n\t */\r\n\twillUnmount?(): void;\r\n\r\n\t/**\r\n\t * Handles an exception that occurred during the component's own rendering or rendering of\r\n\t * one of its descendants. If this method is not implemented or if it throws an error, the\r\n\t * error will be propagated up the chain of components until it reaches a component that\r\n\t * handles it. If none of the components can handle the error, the entire tree will be\r\n\t * unmounted.\r\n\t * @param err An exception that was thrown during the component's own rendering or rendering\r\n\t * of one of its descendants.\r\n\t * @param path An array of names of components and elements from the mounted root to the\r\n\t * component that threw the exception. This path is provided mostly for debugging and tracing\r\n\t * purposes.\r\n\t */\r\n\thandleError?( err: any, path: string[]): void;\r\n\r\n\t/**\r\n\t * Retrieves update strategy object that determines different aspects of component behavior\r\n\t * during updates.\r\n\t */\r\n\tgetUpdateStrategy?(): UpdateStrategy;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The UpdateStrategy object specifies different aspects of update behavior of components and\r\n * elements.\r\n */\r\nexport type UpdateStrategy = \r\n{\r\n\t/**\r\n\t * Flag determining whether non-matching new keyed sub-nodes are allowed to recycle non-\r\n\t * matching old keyed sub-nodes. Here \"non-matching\" means those new or old nodes for which\r\n\t * no old or new sub-nodes respectively were found. If this flag is false, then non-matching\r\n\t * old sub-nodes will be removed and non-matching new sub-nodes will be inserted. If this\r\n\t * flag is true, then non-matching old sub-nodes will be updated by the non-matching new\r\n\t * sub-nodes - provided that the types of sub-nodes are the same.\r\n\t * \r\n\t * If keyed sub-nodes recycling is allowed it can speed up an update process because\r\n\t * less DOM nodes get removed and inserted, which is more expensive than updating. However,\r\n\t * this can have some adverse effects under cirtain circumstances if certain data is bound\r\n\t * to the particular instances of DOM nodes.\r\n\t * \r\n\t * The flag's default value is true.\r\n\t */\r\n\tallowKeyedNodeRecycling?: boolean;\r\n};\r\n\r\n\r\n/**\r\n * Type of functions scheduled to be called either before or after the update cycle.\r\n */\r\nexport type ScheduledFuncType = () => void;\r\n\r\n\r\n\r\n/**\r\n * The IServiceDefinitions interface serves as a mapping between service names and service types.\r\n * This interface is intended to be augmented by modules that define and/or use specific services.\r\n * This allows performing service publishing and subscribing in type-safe manner.\r\n */\r\nexport interface IServiceDefinitions\r\n{\r\n\t/** Built-in error handling service. */\r\n\t\"StdErrorHandling\": IErrorHandlingService;\r\n\r\n\t/**\r\n\t * Built-in service for lazy people - can be used for quick prototypes without the need to\r\n\t * augment the interface.\r\n\t */\r\n\t\"any\": any;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The IErrorHandlingService interface represents a service that can be invoked when an error -\r\n * usually an exception - is encountered but cannot be handled locally. A component that implements\r\n * this service would normally remember the error and request to update itself,so that in its\r\n * render method it will present the error to the user.\r\n *\r\n * The IErrorHandlingService is implemented by the Root Virtual Node as a last resort for error\r\n * handling. The Root VN will display a simple UI showing the error and will allow the user to\r\n * restart - in the hope that the error will not repeat itself.\r\n */\r\nexport interface IErrorHandlingService\r\n{\r\n\treportError( err: any,path: string[]): void;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Base class for components. Components that derive from this class must implement the render\r\n * method.\r\n */\r\nexport abstract class Component<TProps = {}, TChildren = any> implements IComponent<TProps,TChildren>\r\n{\r\n\t/** Component properties passed to the constructor */\r\n\tpublic props: CompProps<TProps,TChildren>;\r\n\r\n\t/** Remembered vn object through which component can request services. */\r\n\tpublic vn: IVNode;\r\n\r\n\tconstructor( props?: CompProps<TProps,TChildren>)\r\n\t{\r\n\t\tif (props)\r\n\t\t\tthis.props = props;\r\n\t}\r\n\r\n\t/** Returns the component's content that will be ultimately placed into the DOM tree. */\r\n\tpublic abstract render(): any;\r\n\r\n\t/** This method is called by the component to request to be updated. */\r\n\tprotected updateMe(): void\r\n\t{\r\n\t\tif (this.vn)\r\n\t\t\tthis.vn.requestUpdate();\r\n\t}\r\n\r\n\t/** This method is called by the component to schedule a function to be invoked on the next\r\n\t * update cycle either before or after the scheduled components are updated.\r\n\t * @param func Function to be called\r\n\t * @param beforeUpdate Flag indicating whether the function should be called before (true)\r\n\t * or after (false) the update cycle.\r\n\t */\r\n\tprotected callMe( func: ScheduledFuncType, beforeUpdate: boolean = false): void\r\n\t{\r\n\t\tif (this.vn)\r\n\t\t\tthis.vn.scheduleCall( func, beforeUpdate);\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Defines event handler that is invoked when reference value changes.\r\n */\r\nexport type RefFunc<T> = (newRef: T) => void;\r\n\r\n\r\n\r\nimport {IEventSlot, EventSlot} from \"../utils/EventSlot\"\r\n\r\n\r\n\r\n/**\r\n * Reference class to use whenever a reference to an object is needed - for example, with JSX `ref`\r\n * attributes and services.\r\n */\r\nexport class Ref<T>\r\n{\r\n\tprivate _r: T;\r\n\r\n\t/** Event that is fired when the referenced value changes */\r\n\tprivate changedEvent: IEventSlot<RefFunc<T>> = new EventSlot<RefFunc<T>>();\r\n\r\n\tconstructor( listener?: RefFunc<T>, initialReferene?: T)\r\n\t{\r\n\t\tif (listener !== undefined)\r\n\t\t\tthis.changedEvent.add( listener);\r\n\r\n\t\tthis._r = initialReferene;\r\n\t}\r\n\r\n\t/** Adds a callback that will be invoked when the value of the reference changes. */\r\n\tpublic addListener( listener: RefFunc<T>)\r\n\t{\r\n\t\tthis.changedEvent.add( listener);\r\n\t}\r\n\r\n\t/** Removes a callback that was added with addListener. */\r\n\tpublic removeListener( listener: RefFunc<T>)\r\n\t{\r\n\t\tthis.changedEvent.remove( listener);\r\n\t}\r\n\r\n\t/** Get accessors to the reference value */\r\n\tpublic get r(): T { return this._r; }\r\n\r\n\t/** Set accessors to the reference value */\r\n\tpublic set r( newRef: T)\r\n\t{\r\n\t\tif (this._r !== newRef)\r\n\t\t{\r\n\t\t\tthis._r = newRef;\r\n\t\t\tthis.changedEvent.fire( newRef);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Clears the reference value and also clears all all registered listeners */\r\n\tpublic clear(): void\r\n\t{\r\n\t\tthis._r = undefined;\r\n\t\tthis.changedEvent.clear();\r\n\t}\r\n}\r\n\r\n\r\n\r\n// ///////////////////////////////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Decorator function for creating reference properties without the need to manually create\r\n// // Ref<> instances. This allows for the following code pattern:\r\n// //\r\n// //\tclass A extends Component\r\n// //\t{\r\n// //\t\t@ref myDiv: HTMLDivElement;\r\n// //\t\trender() { return <div ref={myDiv}>Hello</div>; }\r\n// //\t}\r\n// //\r\n// // In the above example, the myDiv property will be automatically created when first accessed. The\r\n// // actual object will be a Proxy to Ref<> of the given type (HTMLDivElement in this case).\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////////////////////////////\r\n// export function ref( target, name)\r\n// {\r\n// \tfunction refGet( obj, key)\r\n// \t{\r\n// \t\tif (key === \"r\")\r\n// \t\t\treturn obj.r;\r\n// \t\telse\r\n// \t\t\treturn obj.r[key];\r\n// \t}\r\n\r\n// \tfunction refSet( obj, key, val, receiver): boolean\r\n// \t{\r\n// \t\tif (key === \"r\")\r\n// \t\t\tobj.r = val;\r\n// \t\telse\r\n// \t\t\tobj.r[key] = val;\r\n\r\n// \t\treturn true;\r\n// \t}\r\n\r\n// \tfunction ensureProxy( thisObj: any, attrName: string): any\r\n// \t{\r\n// \t\tlet proxy = thisObj[attrName];\r\n// \t\tif (!proxy)\r\n// \t\t{\r\n// \t\t\tproxy = new Proxy( new Ref<any>(), { get: refGet, set: refSet });\r\n// \t\t\tthisObj[attrName] = proxy;\r\n// \t\t}\r\n// \t\treturn proxy;\r\n// \t}\r\n\r\n// \tlet attrName = \"_ref_\" + name;\r\n// \tObject.defineProperty( target, name,\r\n// \t\t{\r\n// \t\t\tset( val) { ensureProxy( this, attrName).r = val; },\r\n// \t\t\tget() { return ensureProxy( this, attrName); }\r\n// \t\t}\r\n// \t);\r\n// }\r\n\r\n\r\n\r\n/**\r\n * Type of ref property that can be passed to JSX elements and components. This can be either the\r\n * [[Ref]] class or [[RefFunc]] function.\r\n */\r\nexport type RefPropType<T = any> = Ref<T> | RefFunc<T>;\r\n\r\n\r\n\r\n/**\r\n * Helper function to set the value of the reference that takes care of the different types of\r\n * references. The optional `onlyIf` parameter may specify a value so that only if the reference\r\n * currently has the same value it will be replaced. This might be needed to not clear a\r\n * reference if it already points to a different object.\r\n * @param ref [[Ref]] object to which the new value will be set\r\n * @param val Reference value to set to the Ref object\r\n * @param onlyIf An optional value to which to compare the current (old) value of the reference.\r\n * The new value will be set only if the old value equals the `onlyIf` value.\r\n */\r\nexport function setRef<T>( ref: RefPropType<T>, val: T, onlyIf?: T): void\r\n{\r\n\tif (typeof ref === \"object\")\r\n\t{\r\n\t\tlet refObj = ref as Ref<T>;\r\n\t\tif (onlyIf === undefined || refObj.r === onlyIf)\r\n\t\t\trefObj.r = val;\r\n\t}\r\n\telse if (typeof ref === \"function\")\r\n\t\t(ref as RefFunc<T>)(val);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Decorator function for defining properties with a set method that calls the updateMe method\r\n * whenever the property value changes.\r\n *\t```typescript\r\n *\tclass Child extends Component\r\n *\t{\r\n *\t\t@mim.updatable text: string = \"Hello!\";\r\n *\t\trender()\r\n *\t\t{\r\n *\t \t\treturn <div>{text}</div>\r\n *\t\t}\r\n *\t}\r\n *\r\n *\tclass Parent extends Component\r\n *\t{\r\n *\t\tchild = new Child();\r\n *\t\trender()\r\n *\t\t{\r\n *\t\t\treturn <div click={() => this.child.text += \" again\"}>{this.child}</div>\r\n *\t\t}\r\n *\t}\r\n *\t```\r\n * In the above example, the Child component will be re-rendered when its `text` property changes.\r\n * \r\n * @param target \r\n * @param name \r\n */\r\nexport function updatable( target, name: string)\r\n{\r\n\tlet attrName = \"_m_\" + name;\r\n\tObject.defineProperty( target, name,\r\n\t\t{\r\n\t\t\tset( val)\r\n\t\t\t{\r\n\t\t\t\tif (this[attrName] !== val)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis[attrName] = val;\r\n\t\t\t\t\tif (this.vn)\r\n\t\t\t\t\t\tthis.vn.requestUpdate();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tget() { return this[attrName]; }\r\n\t\t}\r\n\t);\r\n}\r\n\r\n\r\n\r\n/**\r\n * An artificial \"Fragment\" component that is only used as a temporary collection of other items\r\n * in places where JSX only allows a single item. Our JSX factory function creates a virtual node\r\n * for each of its children and the function is never actually called. This function is only needed\r\n * because currently TypeScript doesn't allow the `<>` fragment notation if a custom JSX factory\r\n * function is used.\r\n *\r\n * Use it as follows:\r\n * ```typescript\r\n *\timport * as mim from \"mimbl\"\r\n *\t.....\r\n *\trender()\r\n *\t{\r\n *\t\treturn <mim.Fragment>\r\n *\t\t\t<div1/>\r\n *\t\t\t<div2/>\r\n *\t\t\t<div3/>\r\n *\t\t</mim.Fragment>\r\n *\t}\r\n  ```\r\n\r\n * @param props \r\n */\r\nexport function Fragment( props: CompProps<{}>): any {}\r\n\r\n\r\n\r\n/** \r\n * The ICustomAttributeHandlerClass interface represents a class of handlers of custom attributes\r\n * that can be applied to intrinsic (HTML or SVG) elements. The requirements on such classes are:\r\n * 1. Implement a constructor accepting IElmVN, attribute value and attribute name (this allows\r\n *   the same handler to serve different attributes).\r\n * 2. Implement the ICustomAttributeHandler interface\r\n */\r\nexport interface ICustomAttributeHandlerClass<T>\r\n{\r\n\t/**\r\n\t * Constructs a new custom attribute handler that will act on the given element and provides\r\n\t * the initial value of the attribute. Attribute name is also provided in case the handler\r\n\t * supports different attributes. By the time this constructor is called, the DOM element had\r\n\t * already been created and standard attributes and event listeners had been applied.\r\n\t * @param elmVN Virtual node for this element. The handler can retrieve the DOM element from\r\n\t *   this interface and also use other methods (e.g. subscribe to services).\r\n\t * @param attrVal Initial value of the custom attribute\r\n\t * @param attrName Name of the custom attribute\r\n\t */\r\n\tnew( elmVN: IElmVN, attrVal: T, attrName?: string): ICustomAttributeHandler<T>;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The ICustomAttributeHandler interface represents an ability to handle custom properties that can\r\n * be applied to intrinsic (HTML or SVG) elements.\r\n */\r\nexport interface ICustomAttributeHandler<T>\r\n{\r\n\t/**\r\n\t * Updates an existing custom attribute with the new value.\r\n\t * @param newPropVal New value of the custom attribute.\r\n\t * @returns True if changes were made and false otherwise.\r\n\t */\r\n\tupdate( newPropVal: T): boolean;\r\n\r\n\t/**\r\n\t * Terminates the functioning of the custom attribute handler. This method is invoked either\r\n\t * when a new rendering of the element doesn't have the attribute anymore or if the element\r\n\t * is removed. Although this method is optional, most handlers will need to implement it to\r\n\t * properly cleanup any resources (e.g. event handlers) to avoid leaks.\r\n\t * @param isRemoval True if the element is being removed and false if the element is being\r\n\t *   updated and the attribute is no longer provided. If the handler adds any event\r\n\t *   listeners to the element, then it has to remove them on update but doen't have to do it\r\n\t *   on element removal.\r\n\t */\r\n\tterminate?( isRemoval: boolean): void;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The FuncProxy component wraps a function that produces content. Proxies can wrap instance\r\n * methods of classes that have access to \"this\" thus allowing a single class to \"host\" multiple\r\n * components that can be updated separately. This is especially useful when there is a hierarchy\r\n * of derived classes and (virtual) methods that deliver several pieces of content. FuncProxies\r\n * can wrap these virtual methods (or other methods that call them) so that the content pieces\r\n * can be updated separately. FuncProxy has a public Update method that should be called to cause\r\n * the rendering mechanism to invoke the function wrapped by the FuncProxy.\r\n */\r\nexport class FuncProxy extends Component\r\n{\r\n\tconstructor( func: () => any)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.func = func;\r\n\t}\r\n\r\n\tpublic update = (): void =>\r\n\t{\r\n\t\tif (this.vn)\r\n\t\t\tthis.vn.requestUpdate();\r\n\t};\r\n\r\n\tpublic render(): any\r\n\t{\r\n\t\treturn this.func();\r\n\t}\r\n\r\n\tprivate func: () => any;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The Waiting component wraps a Promise and replaces its content when the promise is settled.\r\n * Before the promise is settled, the component displays an optional \"in-progress\" content\r\n * specified in the constructor. If the promise is rejected, the component will either display\r\n * the \"error\" content obtained by calling a functions specified in the constructor or if such\r\n * function is not specified show empty content.\r\n */\r\nexport class Waiting extends Component\r\n{\r\n\t/**\r\n\t * Constructs the object\r\n\t * @param promise Promise object to wait for\r\n\t * @param progressContent Content to display while waiting for the promise\r\n\t * @param errorContentFunc Content to display if the promise is rejected\r\n\t */\r\n\tconstructor( promise: Promise<any>, progressContent?: any, errorContentFunc?: (err: any) => any)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.content = progressContent;\r\n\r\n\t\tthis.watchPromise( promise, errorContentFunc);\r\n\t}\r\n\r\n\tpublic render(): any\r\n\t{\r\n\t\treturn this.content;\r\n\t}\r\n\r\n\tprivate async watchPromise(promise: Promise<any>,errorContentFunc?: (err: any) => any): Promise<any>\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tthis.content = await promise;\r\n\t\t}\r\n\t\tcatch( err)\r\n\t\t{\r\n\t\t\tthis.content = null;\r\n\t\t\tif (errorContentFunc !== undefined)\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.content = errorContentFunc( err);\r\n\t\t\t\t}\r\n\t\t\t\tcatch(anotherErr)\r\n\t\t\t\t{\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate content: any;\r\n}\r\n\r\n\r\n\r\n/** Defines types of virtual DOM nodes */\r\nexport const enum VNType\r\n{\r\n\t// Top-level node\r\n\tRoot,\r\n\r\n\t// Class-based (state-full) component created via new\r\n\tIndependentComp,\r\n\r\n\t// Class-based (state-full) JSX-based component laid out using JSX\r\n\tManagedComp,\r\n\r\n\t// Stateless component (simple rendering function accepting props)\r\n\tFuncComp,\r\n\r\n\t// DOM element (HTML or SVG) laid out using JSX.\r\n\tElm,\r\n\r\n\t// Text node\r\n\tText,\r\n}\r\n\r\n\r\n\r\n/**\r\n * The IVNode interface represents a virtual node. Through this interface, callers can perform\r\n * most common actions that are available on every type of virtual node. Each type of virtual node\r\n * also implements a more specific interface through which the specific capabilities of the node\r\n * type are available.\r\n */\r\nexport interface IVNode\r\n{\r\n\t/** Gets node type. */\r\n\treadonly type: VNType;\r\n\r\n\t/** Gets node's parent. This is undefined for the top-level (root) nodes. */\r\n\treadonly parent?: IVNode;\r\n\r\n\t/** Reference to the next sibling node or undefined for the last sibling. */\r\n\treadonly next?: IVNode;\r\n\r\n\t/** Reference to the previous sibling node or undefined for the first sibling. */\r\n\treadonly prev?: IVNode;\r\n\r\n\t/** List of sub-nodes. */\r\n\treadonly subNodes?: IVNode[];\r\n\r\n\t/**\r\n\t * Gets node's display name. This is used mostly for tracing and error reporting. The name\r\n\t * can change during the lifetime of the virtual node; for example, it can reflect an \"id\"\r\n\t * property of an element.\r\n\t */\r\n\treadonly name?: string;\r\n\r\n\r\n\r\n\t/** This method is called by the component when it needs to be updated. */\r\n\trequestUpdate(): void;\r\n\r\n\t/**\r\n\t * Schedules to call the given function either before or after all the scheduled components\r\n\t * have been updated.\r\n\t * @param func Function to be called either before or after the update cycle.\r\n\t * @param beforeUpdate Flag indicating whether the function should be called before (true)\r\n\t * or after (false) the update cycle.\r\n\t */\r\n\tscheduleCall( func: ScheduledFuncType, beforeUpdate: boolean): void;\r\n\r\n\r\n\r\n\t/**\r\n\t * Registers an object of any type as a service with the given ID that will be available for\r\n\t * consumption by descendant components.\r\n\t */\r\n\tpublishService<K extends keyof IServiceDefinitions>( id: K, service: IServiceDefinitions[K]): void;\r\n\r\n\t/** Unregisters a service with the given ID. */\r\n\tunpublishService<K extends keyof IServiceDefinitions>( id: K): void;\r\n\r\n\t/**\r\n\t * Subscribes to a service with the given ID. If the service with the given ID is registered\r\n\t * by this or one of the ancestor components, the passed Ref object will reference it;\r\n\t * otherwise, the Ref object will be set to the defaultValue (if specified) or will remain\r\n\t * undefined. Whenever the value of the service that is registered by this or a closest\r\n\t * ancestor component is changed,the Ref object will receive the new value.\r\n\t * The useSelf optional parameter determines whether the component can subscribe to the\r\n\t * service published by itself. The default is false.\r\n\t * @param id \r\n\t * @param ref \r\n\t * @param defaultService \r\n\t * @param useSelf \r\n\t */\r\n\tsubscribeService<K extends keyof IServiceDefinitions>( id: K, ref: RefPropType<IServiceDefinitions[K]>,\r\n\t\t\t\t\tdefaultService?: IServiceDefinitions[K], useSelf?: boolean): void;\r\n\r\n\t/**\r\n\t * Unsubscribes from a service with the given ID. The Ref object that was used to subscribe\r\n\t * will be set to undefined.\r\n\t * @param id \r\n\t */\r\n\tunsubscribeService<K extends keyof IServiceDefinitions>( id: K): void;\r\n\r\n\t/**\r\n\t * Retrieves the value for a service with the given ID registered by a closest ancestor\r\n\t * component or the default value if none of the ancestor components registered a service with\r\n\t * this ID. This method doesn't establish a subscription and only reflects the current state.\r\n\t * @param id \r\n\t * @param defaultService \r\n\t * @param useSelf \r\n\t */\r\n\tgetService<K extends keyof IServiceDefinitions>( id: K, defaultService?: IServiceDefinitions[K],\r\n\t\t\t\t\tuseSelf?: boolean): IServiceDefinitions[K];\r\n\r\n\r\n\r\n\t/**\r\n\t * Creates a wrapper function with the same signature as the given callback so that if the original\r\n\t * callback throws an exception, it is processed by the Mimble error handling mechanism so that the\r\n\t * exception bubles from this virtual node up the hierarchy until a node/component that knows to\r\n\t * handle errors is found.\r\n\t * \r\n\t * This function should be called by the code that is not part of any component but still has access\r\n\t * to the IVNode object; for example, custom attribute handlers. Components that derive from the\r\n\t * mim.Component class should use the wrapCallback method of the mim.Component class.\r\n\t * \r\n\t * Use this method before passing callbacks to document and window event handlers as well as\r\n\t * non-DOM objects that use callbacks, e.g. promises. For example:\r\n\t * \r\n\t * ```typescript\r\n\t *\tclass ResizeMonitor\r\n\t *\t{\r\n\t *\t\tprivate onWindowResize = (e: Event): void => {};\r\n\t *\r\n\t * \t\twrapper: (e: Event): void;\r\n\t * \r\n\t * \t\tpublic startResizeMonitoring( vn: IVNode)\r\n\t *\t\t{\r\n\t *\t\t\tthis.wrapper = vn.wrapCallback( this.onWindowResize);\r\n\t *\t\t\twindow.addEventListener( \"resize\", this.wrapper);\r\n\t *\t\t}\r\n\t * \r\n\t * \t\tpublic stopResizeMonitoring()\r\n\t *\t\t{\r\n\t *\t\t\twindow.removeEventListener( \"resize\", this.wrapper);\r\n\t *\t\t\tthis.wrapper = undefined;\r\n\t *\t\t}\r\n\t *\t}\r\n\t * ```\r\n\t * \r\n\t * @param callback Callback to be wrapped\r\n\t * @returns Function that has the same signature as the given callback and that should be used\r\n\t *     instead of the original callback\r\n\t */\r\n\twrapCallback<T>( callback: T, that?: any): T;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The IClassCompVN interface represents a virtual node for a JSX-based component.\r\n */\r\nexport interface IClassCompVN extends IVNode\r\n{\r\n\t/** Gets the component instance. */\r\n\treadonly comp: IComponent;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The IInstanceVN interface represents a virtual node for a component.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface IIndependentCompVN extends IVNode\r\n{\r\n}\r\n\r\n\r\n\r\n/**\r\n * The IClassVN interface represents a virtual node for a JSX-based component.\r\n */\r\nexport interface IManagedCompVN extends IVNode\r\n{\r\n\t/** Gets the component class. */\r\n\treadonly compClass: IComponentClass;\r\n}\r\n\r\n\r\n\r\n/**\r\n *  The IElmVN interface represents a virtual node for a DOM element.\r\n */\r\nexport interface IElmVN extends IVNode\r\n{\r\n\t/** Gets the element name. */\r\n\treadonly elmName: string;\r\n\r\n\t/** Gets the flag indicating whether this element is an SVG (as opposed to HTML). */\r\n\treadonly isSvg: boolean;\r\n\r\n\t/** Gets the element instance. */\r\n\treadonly elm: Element;\r\n\r\n\t/** Component that created this element in its render method. */\r\n\treadonly creator: IComponent;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The ITextVN interface represents a virtual node for a text DOM node.\r\n */\r\nexport interface ITextVN extends IVNode\r\n{\r\n\t/** Text of the node. */\r\n\ttext: string;\r\n\r\n\t/** Text DOM node. */\r\n\ttextNode: Text;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The Slice type defines an object structure describing\r\n * parameters for rendering an element. They include: Class, Style, Properties, Content. This\r\n * structure is intended to be passed either in the constructor or via the protected methods of\r\n * derived classes, so that they can control parameters of elements rendered by the upper classes.\r\n * The main purpose of this structure is to combine parameters defining an element into a single\r\n * object to minimize the number of properties callers of classes should deal with.\r\n */\r\nexport type Slice =\r\n{\r\n\tclassName?: string;\r\n\tstyle?: StylePropType;\r\n\tprops?: object\r\n\tcontent?: any;\r\n};\r\n\r\n\r\n\r\n/**\r\n *  Styles\r\n */\r\nexport type StylePropType = Partial<CSSStyleDeclaration>;\r\n\r\n/**\r\n * Type of event handler function for DOM events of type T.\r\n * @typeparam T DOM event type, e.g. MouseEvent\r\n */\r\nexport type EventFuncType<T extends Event> = (e: T) => void;\r\n\r\n/**\r\n * Tuple combining the event handler type and object that will be bound as \"this\" when the handler\r\n * is invoked.\r\n * @typeparam T DOM event type, e.g. MouseEvent\r\n */\r\nexport type EventFuncAndThisType<T extends Event> = [EventFuncType<T>, object];\r\n\r\n/**\r\n * Tuple combining the event handler type and the Boolean flag indicating whether the event\r\n * handler should be attached to the capture (true) or to the bubble (false) phase.\r\n * @typeparam T DOM event type, e.g. MouseEvent\r\n */\r\nexport type EventFuncAndFlagType<T extends Event> = [EventFuncType<T>, boolean];\r\n\r\n/**\r\n * Tuple combining the event handler type, object that will be bound as \"this\" when the handler\r\n * is invoked and the Boolean flag indicating whether the event handler should be attached to the\r\n * capture (true) or to the bubble (false) phase.\r\n * @typeparam T DOM event type, e.g. MouseEvent\r\n */\r\nexport type EventFuncAndThisAndFlagType<T extends Event> = [EventFuncType<T>, any, boolean];\r\n\r\n/**\r\n * Union type that can be passed to an Element's event. It is either an event handler function\r\n * or a tuple consisting of the handler function and the flag indicating whether the event\r\n * handler should be attached to the capture (true) or to the bubble (false) phase.\r\n * @typeparam T DOM event type, e.g. MouseEvent\r\n */\r\nexport type EventPropType<T extends Event> = EventFuncType<T> | EventFuncAndThisType<T> |\r\n\t\t\t\tEventFuncAndFlagType<T> | EventFuncAndThisAndFlagType<T>;\r\n\r\n\r\n\r\n/**\r\n * The ICommonProps interface defines standard properties that can be used on all JSX elements -\r\n * intrinsic (HTML and SVG) as well as functional and class-based components.\r\n */\r\nexport interface ICommonProps\r\n{\r\n\t/** Unique key that distinguishes this JSX element from its siblings. The key can be of any type. */\r\n\tkey?: any;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Definitions of property types used by HTML and SVG elements.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport type ColorPropType = string;\r\nexport type CrossoriginPropType = \"anonymous\" | \"use-credentials\";\r\nexport type FormenctypePropType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\" | \"text/plain\";\r\nexport type FormmethodPropType = \"get\" | \"post\" | \"dialog\";\r\nexport type FormtargetPropType = string | \"_self\" | \"_blank\" | \"_parent\"| \"_top\";\r\nexport type ReferrerPolicyPropType = \"no-referrer\" | \"no-referrer-when-downgrade\" | \"origin\" |\r\n\t\t\"origin-when-cross-origin\" | \"unsafe-url\";\r\n\r\n/**\r\n * The IElementProps interface defines standard properties (attributes and event listeners)\r\n * that can be used on all HTML and SVG elements.\r\n */\r\nexport interface IElementProps<TRef,TChildren = any> extends ICommonProps\r\n{\r\n\t/**\r\n\t * Reference that will be set to the instance of the element after it is created (mounted). The\r\n\t * reference will be set to undefined after the element is unmounted.\r\n\t */\r\n\tref?: RefPropType<TRef>;\r\n\r\n\t/**\r\n\t * Update strategy object that determines different aspects of element behavior during updates.\r\n\t */\r\n\tupdateStrategy?: UpdateStrategy;\r\n\r\n\t/** Children that can be supplied to the element */\r\n\tchildren?: TChildren;\r\n\r\n\t// standard HTML and SVG element properties\r\n\tclass?: string\r\n\tdraggable?: boolean;\r\n\tdropzone ?: \"copy\" | \"move\" | \"link\";\r\n\tid?: string | number;\r\n\tlang?: string;\r\n\trole?: string;\r\n\tstyle?: StylePropType;\r\n\ttabindex?: number;\r\n\r\n\t// global events\r\n\tabort?: EventPropType<UIEvent>;\r\n\tanimationcancel?: EventPropType<AnimationEvent>;\r\n\tanimationend?: EventPropType<AnimationEvent>;\r\n\tanimationiteration?: EventPropType<AnimationEvent>;\r\n\tanimationstart?: EventPropType<AnimationEvent>;\r\n\tauxclick?: EventPropType<Event>;\r\n\tblur?: EventPropType<FocusEvent>;\r\n\tcancel?: EventPropType<Event>;\r\n\tcanplay?: EventPropType<Event>;\r\n\tcanplaythrough?: EventPropType<Event>;\r\n\tchange?: EventPropType<Event>;\r\n\tclick?: EventPropType<MouseEvent>;\r\n\tclose?: EventPropType<Event>;\r\n\tcontextmenu?: EventPropType<MouseEvent>;\r\n\tcuechange?: EventPropType<Event>;\r\n\tdblclick?: EventPropType<MouseEvent>;\r\n\tdurationchange?: EventPropType<Event>;\r\n\temptied?: EventPropType<Event>;\r\n\tended?: EventPropType<Event>;\r\n\terror?: EventPropType<ErrorEvent>;\r\n\tfocus?: EventPropType<FocusEvent>;\r\n\tgotpointercapture?: EventPropType<PointerEvent>;\r\n\tinput?: EventPropType<Event>;\r\n\tinvalid?: EventPropType<Event>;\r\n\tkeydown?: EventPropType<KeyboardEvent>;\r\n\tkeypress?: EventPropType<KeyboardEvent>;\r\n\tkeyup?: EventPropType<KeyboardEvent>;\r\n\tload?: EventPropType<Event>;\r\n\tloadeddata?: EventPropType<Event>;\r\n\tloadedmetadata?: EventPropType<Event>;\r\n\tloadend?: EventPropType<ProgressEvent>;\r\n\tloadstart?: EventPropType<Event>;\r\n\tlostpointercapture?: EventPropType<PointerEvent>;\r\n\tmousedown?: EventPropType<MouseEvent>;\r\n\tmouseenter?: EventPropType<MouseEvent>;\r\n\tmouseleave?: EventPropType<MouseEvent>;\r\n\tmousemove?: EventPropType<MouseEvent>;\r\n\tmouseout?: EventPropType<MouseEvent>;\r\n\tmouseover?: EventPropType<MouseEvent>;\r\n\tmouseup?: EventPropType<MouseEvent>;\r\n\tpause?: EventPropType<Event>;\r\n\tplay?: EventPropType<Event>;\r\n\tplaying?: EventPropType<Event>;\r\n\tpointercancel?: EventPropType<PointerEvent>;\r\n\tpointerdown?: EventPropType<PointerEvent>;\r\n\tpointerenter?: EventPropType<PointerEvent>;\r\n\tpointerleave?: EventPropType<PointerEvent>;\r\n\tpointermove?: EventPropType<PointerEvent>;\r\n\tpointerout?: EventPropType<PointerEvent>;\r\n\tpointerover?: EventPropType<PointerEvent>;\r\n\tpointerup?: EventPropType<PointerEvent>;\r\n\tprogress?: EventPropType<ProgressEvent>;\r\n\tratechange?: EventPropType<Event>;\r\n\treset?: EventPropType<Event>;\r\n\tresize?: EventPropType<UIEvent>;\r\n\tscroll?: EventPropType<UIEvent>;\r\n\t//securitypolicyviolation?: EventPropType<SecurityPolicyViolationEvent>;\r\n\tseeked?: EventPropType<Event>;\r\n\tseeking?: EventPropType<Event>;\r\n\tselect?: EventPropType<UIEvent>;\r\n\tstalled?: EventPropType<Event>;\r\n\tsubmit?: EventPropType<Event>;\r\n\tsuspend?: EventPropType<Event>;\r\n\ttimeupdate?: EventPropType<Event>;\r\n\ttoggle?: EventPropType<Event>;\r\n\ttouchcancel?: EventPropType<TouchEvent>;\r\n\ttouchend?: EventPropType<TouchEvent>;\r\n\ttouchenter?: EventPropType<TouchEvent>;\r\n\ttouchleave?: EventPropType<TouchEvent>;\r\n\ttouchmove?: EventPropType<TouchEvent>;\r\n\ttouchstart?: EventPropType<TouchEvent>;\r\n\ttransitioncancel?: EventPropType<TransitionEvent>;\r\n\ttransitionend?: EventPropType<TransitionEvent>;\r\n\ttransitionrun?: EventPropType<TransitionEvent>;\r\n\ttransitionstart?: EventPropType<TransitionEvent>;\r\n\tvolumechange?: EventPropType<Event>;\r\n\twaiting?: EventPropType<Event>;\r\n\twheel?: EventPropType<WheelEvent>;\r\n\r\n\t// Element's events\r\n\tfullscreenchange?: EventPropType<Event>;\r\n\tfullscreenerror?: EventPropType<Event>;\r\n\r\n\t// Document's and Element's events\r\n\tcopy?: EventPropType<ClipboardEvent>;\r\n\tcut?: EventPropType<ClipboardEvent>;\r\n\tpaste?: EventPropType<ClipboardEvent>;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Utility functions for determining whether an element is an SVG.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Determines whether the given element is one of the elements from the SVG spec; that is, <svg>\r\n * or any other from SVG.\r\n * @param elm Element to test\r\n */\r\nexport function isSvg( elm: Element): boolean\r\n{\r\n\treturn \"ownerSVGElement\" in (elm as any);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Determines whether the given element is the <svg> element.\r\n * @param elm  Element to test\r\n */\r\nexport function isSvgSvg( elm: Element): boolean\r\n{\r\n\treturn (elm as any).ownerSVGElement === null;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// JSX namespace defining how TypeScript performs type checks on JSX elements,components\r\n// properties and children.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nimport * as html from \"./HtmlTypes\";\r\nimport * as svg from \"./SvgTypes\";\r\n\r\n\r\n\r\n/**\r\n * Namespace defining interfaces used by TypeScript to type-check JSX expressions.\r\n */\r\nexport namespace JSX\r\n{\r\n\t// // tslint:disable-next-line:no-empty-interface\r\n\t// export interface Element extends IVNode[] {}\r\n\r\n\t// tslint:disable-next-line:no-empty-interface\r\n\texport interface ElementClass extends IComponent {}\r\n\r\n\texport interface ElementAttributesProperty { props: {} }\r\n\r\n\texport interface ElementChildrenAttribute { children: any }\r\n\t\r\n\texport interface IntrinsicElements\r\n\t{\r\n\t\t// HTML elements\r\n\t\ta: html.IHtmlAElementProps;\r\n\t\tabbr: html.IHtmlElementProps;\r\n\t\tacronym: html.IHtmlElementProps;\r\n\t\taddress: html.IHtmlElementProps;\r\n\t\tapplet: html.IHtmlAppletElementProps;\r\n\t\tarea: html.IHtmlAreaElementProps;\r\n\t\tarticle: html.IHtmlElementProps;\r\n\t\taside: html.IHtmlElementProps;\r\n\t\taudio: html.IHtmlAudioElementProps;\r\n\r\n\t\tb: html.IHtmlElementProps;\r\n\t\tbase: html.IHtmlBaseElementProps;\r\n\t\tbasefont: html.IHtmlBasefontElementProps;\r\n\t\tbdi: html.IHtmlElementProps;\r\n\t\tbdo: html.IHtmlElementProps;\r\n\t\tbig: html.IHtmlElementProps;\r\n\t\tblockquote: html.IHtmlBlockquoteElementProps;\r\n\t\tbody: html.IHtmlElementProps;\r\n\t\tbr: html.IHtmlBrElementProps;\r\n\t\tbutton: html.IHtmlButtonElementProps;\r\n\r\n\t\tcanvas: html.IHtmlCanvasElementProps;\r\n\t\tcaption: html.IHtmlCaptionElementProps;\r\n\t\tcenter: html.IHtmlElementProps;\r\n\t\tcite: html.IHtmlElementProps;\r\n\t\tcode: html.IHtmlElementProps;\r\n\t\tcol: html.IHtmlColElementProps;\r\n\t\tcolgroup: html.IHtmlColgroupElementProps;\r\n\r\n\t\tdata: html.IHtmlDataElementProps;\r\n\t\tdatalist: html.IHtmlDataListElementProps;\r\n\t\tdd: html.IHtmlDdElementProps;\r\n\t\tdel: html.IHtmlDelElementProps;\r\n\t\tdetails: html.IHtmlDetailsElementProps;\r\n\t\tdfn: html.IHtmlElementProps;\r\n\t\tdialog: html.IHtmlDialogElementProps;\r\n\t\tdir: html.IHtmlDirElementProps;\r\n\t\tdiv: html.IHtmlDivElementProps;\r\n\t\tdl: html.IHtmlDlElementProps;\r\n\t\tdt: html.IHtmlElementProps;\r\n\r\n\t\tem: html.IHtmlElementProps;\r\n\t\tembed: html.IHtmlEmbedElementProps;\r\n\r\n\t\tfieldset: html.IHtmlFieldsetElementProps;\r\n\t\tfigcaption: html.IHtmlElementProps;\r\n\t\tfigure: html.IHtmlElementProps;\r\n\t\tfont: html.IHtmlFontElementProps;\r\n\t\tfooter: html.IHtmlElementProps;\r\n\t\tform: html.IHtmlFormElementProps;\r\n\t\tframe: html.IHtmlFrameElementProps;\r\n\t\tframeset: html.IHtmlFramesetElementProps;\r\n\r\n\t\th1: html.IHtmlH1ElementProps;\r\n\t\th2: html.IHtmlH2ElementProps;\r\n\t\th3: html.IHtmlH3ElementProps;\r\n\t\th4: html.IHtmlH4ElementProps;\r\n\t\th5: html.IHtmlH5ElementProps;\r\n\t\th6: html.IHtmlH6ElementProps;\r\n\t\thead: html.IHtmlHeadElementProps;\r\n\t\theader: html.IHtmlElementProps;\r\n\t\thgroup: html.IHtmlElementProps;\r\n\t\thr: html.IHtmlHrElementProps;\r\n\t\thtml: html.IHtmlHtmlElementProps;\r\n\r\n\t\ti: html.IHtmlElementProps;\r\n\t\tiframe: html.IHtmlIframeElementProps;\r\n\t\timg: html.IHtmlImgElementProps;\r\n\t\tinput: html.IHtmlInputElementProps;\r\n\t\tins: html.IHtmlInsElementProps;\r\n\r\n\t\tkbd: html.IHtmlElementProps;\r\n\t\tkeygen: html.IHtmlElementProps;\r\n\r\n\t\tlabel: html.IHtmlLabelElementProps;\r\n\t\tlegend: html.IHtmlLegendElementProps;\r\n\t\tli: html.IHtmlLiElementProps;\r\n\t\tlink: html.IHtmlLinkElementProps;\r\n\t\tlisting: html.IHtmlListingElementProps;\r\n\r\n\t\tmain: html.IHtmlElementProps;\r\n\t\tmap: html.IHtmlMapElementProps;\r\n\t\tmark: html.IHtmlElementProps;\r\n\t\tmenu: html.IHtmlMenuElementProps;\r\n\t\tmenuitem: html.IHtmlElementProps;\r\n\t\tmeta: html.IHtmlMetaElementProps;\r\n\t\tmeter: html.IHtmlMeterElementProps;\r\n\r\n\t\tnav: html.IHtmlElementProps;\r\n\t\tnobr: html.IHtmlElementProps;\r\n\t\tnoframes: html.IHtmlElementProps;\r\n\t\tnoscript: html.IHtmlElementProps;\r\n\r\n\t\tobject: html.IHtmlObjectElementProps;\r\n\t\tol: html.IHtmlOlElementProps;\r\n\t\toptgroup: html.IHtmlOptgroupElementProps;\r\n\t\toption: html.IHtmlOptionElementProps;\r\n\t\toutput: html.IHtmlOutputElementProps;\r\n\r\n\t\tp: html.IHtmlPElementProps;\r\n\t\tparam: html.IHtmlParamElementProps;\r\n\t\tpicture: html.IHtmlPictureElementProps;\r\n\t\tpre: html.IHtmlPreElementProps;\r\n\t\tprogress: html.IHtmlProgressElementProps;\r\n\r\n\t\tq: html.IHtmlQElementProps;\r\n\r\n\t\trb: html.IHtmlElementProps;\r\n\t\trp: html.IHtmlElementProps;\r\n\t\trt: html.IHtmlElementProps;\r\n\t\trtc: html.IHtmlElementProps;\r\n\t\truby: html.IHtmlElementProps;\r\n\r\n\t\ts: html.IHtmlElementProps;\r\n\t\tsamp: html.IHtmlElementProps;\r\n\t\tscript: html.IHtmlScriptElementProps;\r\n\t\tsection: html.IHtmlElementProps;\r\n\t\tselect: html.IHtmlSelectElementProps;\r\n\t\tslot: html.IHtmlSlotElementProps;\r\n\t\tsmall: html.IHtmlElementProps;\r\n\t\tsource: html.IHtmlSourceElementProps;\r\n\t\tspan: html.IHtmlSpanElementProps;\r\n\t\tstrike: html.IHtmlElementProps;\r\n\t\tstrong: html.IHtmlElementProps;\r\n\t\tstyle: html.IHtmlStyleElementProps;\r\n\t\tsub: html.IHtmlElementProps;\r\n\t\tsummary: html.IHtmlElementProps;\r\n\t\tsup: html.IHtmlElementProps;\r\n\r\n\t\ttable: html.IHtmlTableElementProps;\r\n\t\ttbody: html.IHtmlTbodyElementProps;\r\n\t\ttd: html.IHtmlTdElementProps;\r\n\t\ttemplate: html.IHtmlTemplateElementProps;\r\n\t\ttextarea: html.IHtmlTextareaElementProps;\r\n\t\ttfoot: html.IHtmlTfootElementProps;\r\n\t\tth: html.IHtmlThElementProps;\r\n\t\tthead: html.IHtmlTHeadElementProps;\r\n\t\ttime: html.IHtmlTimeElementProps;\r\n\t\ttitle: html.IHtmlTitleElementProps;\r\n\t\ttr: html.IHtmlTrElementProps;\r\n\t\ttrack: html.IHtmlTrackElementProps;\r\n\t\ttt: html.IHtmlElementProps;\r\n\r\n\t\tu: html.IHtmlElementProps;\r\n\t\tul: html.IHtmlUlElementProps;\r\n\r\n\t\tvar: html.IHtmlElementProps;\r\n\t\tvideo: html.IHtmlVideoElementProps;\r\n\r\n\t\twbr: html.IHtmlElementProps;\r\n\r\n\t\txmp: html.IHtmlXmpElementProps;\r\n\r\n\t\t// SVG elements\r\n\t\tsvg: svg.ISvgSvgElementProps;\r\n\r\n\t\tsvgA: svg.ISvgAElementProps;\r\n\t\tanimate: svg.ISvgConditionalProcessingProps | svg.ISvgAnimationProps;\r\n\t\tanimateMotion: svg.ISvgAnimateMotionElementProps;\r\n\t\tanimateTarnsform: svg.ISvgConditionalProcessingProps | svg.ISvgAnimationProps;\r\n\r\n\t\tcircle: svg.ISvgCircleElementProps;\r\n\t\tclipPath: svg.ISvgClipPathElementProps;\r\n\t\tcolorProfile: svg.ISvgColorProfilePathElementProps;\r\n\r\n\t\tdefs: svg.ISvgElementProps;\r\n\t\tdesc: svg.ISvgElementProps;\r\n\t\tdiscard: svg.ISvgDiscardElementProps;\r\n\r\n\t\tellipse: svg.ISvgEllipseElementProps;\r\n\r\n\t\tfeBlend: svg.ISvgFeBlendElementProps;\r\n\t\tfeColorMatrix: svg.ISvgFeColorMatrixElementProps;\r\n\t\tfeComponentTransfer: svg.ISvgFeComponentTransferElementProps;\r\n\t\tfeComposite: svg.ISvgFeCompositeElementProps;\r\n\t\tfeConvolveMatrix: svg.ISvgFeConvolveMatrixElementProps;\r\n\t\tfeDiffuseLighting: svg.ISvgFeDiffuseLightingElementProps;\r\n\t\tfeDisplacementMap: svg.ISvgFeDisplacementMapElementProps;\r\n\t\tfeDistantLight: svg.ISvgFeDistantLightElementProps;\r\n\t\tfeDropShadow: svg.ISvgFeDropShadowElementProps;\r\n\t\tfeFlood: svg.ISvgFeFloodElementProps;\r\n\t\tfeFuncA: svg.ISvgTransferFunctionsProps;\r\n\t\tfeFuncB: svg.ISvgTransferFunctionsProps;\r\n\t\tfeFuncG: svg.ISvgTransferFunctionsProps;\r\n\t\tfeFuncR: svg.ISvgTransferFunctionsProps;\r\n\t\tfeGaussianBlur: svg.ISvgFeGaussianBlurElementProps;\r\n\t\tfeImage: svg.ISvgFeImageElementProps;\r\n\t\tfeMerge: svg.ISvgPresentationProps | svg.ISvgFilterPrimitiveProps;\r\n\t\tfeMergeNode: svg.ISvgFeMergeNodeElementProps;\r\n\t\tfeMorphology: svg.ISvgFeMorphologyElementProps;\r\n\t\tfeOffset: svg.ISvgFeOffsetElementProps;\r\n\t\tfePointLight: svg.ISvgFePointLightElementProps;\r\n\t\tfeSpecularLighting: svg.ISvgFeSpecularLightingElementProps;\r\n\t\tfeSpotLight: svg.ISvgFeSpotLightElementProps;\r\n\t\tfeTile: svg.ISvgFeTileElementProps;\r\n\t\tfeTurbulence: svg.ISvgFeTurbulenceElementProps;\r\n\t\tfilter: svg.ISvgFilterElementProps;\r\n\t\tforeignObject: svg.ISvgForeignObjectElementProps;\r\n\r\n\t\tg: svg.ISvgConditionalProcessingProps | svg.ISvgPresentationProps;\r\n\r\n\t\thatch: svg.ISvgHatchElementProps;\r\n\t\thatchpath: svg.ISvgHatchpathElementProps;\r\n\r\n\t\timage: svg.ISvgImageElementProps;\r\n\r\n\t\tline: svg.ISvgLineElementProps;\r\n\t\tlinearGradient: svg.ISvgLinearGradientElementProps;\r\n\r\n\t\tmarker: svg.ISvgMarkerElementProps;\r\n\t\tmask: svg.ISvgMaskElementProps;\r\n\t\tmetadata: svg.ISvgElementProps;\r\n\t\tmpath: svg.ISvgMPathElementProps;\r\n\r\n\t\tpath: svg.ISvgPathElementProps;\r\n\t\tpattern: svg.ISvgPatternElementProps;\r\n\t\tpolygon: svg.ISvgPolygonElementProps;\r\n\t\tpolyline: svg.ISvgPolylineElementProps;\r\n\r\n\t\tradialGradient: svg.ISvgRadialGradientElementProps;\r\n\t\trect: svg.ISvgRectElementProps;\r\n\r\n\t\tsvgScript: svg.ISvgScriptElementProps;\r\n\t\tset: svg.ISvgSetElementProps;\r\n\t\tsolidcolor: svg.ISvgElementProps;\r\n\t\tstop: svg.ISvgStopElementProps;\r\n\t\tsvgStyle: svg.ISvgStyleElementProps;\r\n\t\tswitch: svg.ISvgConditionalProcessingProps | svg.ISvgPresentationProps;\r\n\t\tsymbol: svg.ISvgSymbolElementProps;\r\n\r\n\t\ttext: svg.ISvgTextElementProps;\r\n\t\ttextPath: svg.ISvgTextPathElementProps;\r\n\t\tsvgTitle: svg.ISvgElementProps;\r\n\t\ttextSpan: svg.ISvgTextSpanElementProps;\r\n\r\n\t\tuse: svg.ISvgUseElementProps;\r\n\r\n\t\tview: svg.ISvgViewElementProps;\r\n\r\n\t\t//[elemName: string]: any\r\n\t}\r\n\r\n\t// tslint:disable-next-line:no-empty-interface\r\n\t// Properties in this interface apply to intrinsic elements and to functional components.\r\n\texport interface IntrinsicAttributes extends ICommonProps {}\r\n\r\n\t// Properties in this interface apply to class-based components.\r\n\texport interface IntrinsicClassAttributes<T> extends ICommonProps\r\n\t{\r\n\t\t// Reference that will be set to the instance of the component after it is mounted. The\r\n\t\t// reference will be set to undefined after the component is unmounted.\r\n\t\tref?: RefPropType<T>;\r\n\t}\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Definition of mim.jsx function - JSX Factory\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nimport {createNodesFromJSX} from \"../core/ContentFuncs\"\r\n\r\n/**\r\n * JSX Factory function. In order for this function to be invoked by the TypeScript compiler, the\r\n * tsconfig.json must have the following option:\r\n *\r\n * \"compilerOptions\":\r\n * {\r\n *     \"jsx\": \"react\",\r\n *     \"jsxFactory\": \"mim.jsx\"\r\n * }\r\n *\r\n * The .tsx files must import the mimbl module as mim: import * as mim from \"mimbl\"\r\n * @param tag \r\n * @param props \r\n * @param children \r\n */\r\nexport function jsx( tag: any, props: any, ...children: any[]): any\r\n{\r\n\treturn createNodesFromJSX( tag, props, children);\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Definitions of mount/unmount functions\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nimport * as root from \"../core/RootVN\"\r\n\r\n/**\r\n * Renders the given content (usually result of JSX expression) under the given HTML element in a\r\n * synchronous manner.\r\n * @param content Content to render.\r\n * @param anchorDN DOM element under which to render the content. If null or undefined, then\r\n * render under the document.body tag.\r\n */\r\nexport function mountSync( content: any, anchorDN: Node = null): void\r\n{\r\n\troot.mountRootSync( content, anchorDN);\r\n}\r\n\r\n// \r\n/**\r\n * Removes the content that was originally generated by the mountSync function.\r\n * @param anchorDN DOM element under which the content was previously rendered.\r\n */\r\nexport function unmountSync( anchorDN: Node = null): void\r\n{\r\n\troot.unmountRootSync( anchorDN);\r\n}\r\n\r\n/**\r\n * Renders the given content (usually result of JSX expression) under the given HTML element\r\n// asynchronously.\r\n * @param content Content to render.\r\n * @param anchorDN DOM element under which to render the content. If null or undefined,then\r\n *\t\t\t\trender under the document.body tag.\r\n */\r\nexport function mount( content: any, anchorDN: Node = null): void\r\n{\r\n\troot.mountRoot( content, anchorDN);\r\n}\r\n\r\n/**\r\n * Removes the content that was originally generated by the mount function.\r\n * @param anchorDN DOM element under which the content was previously rendered.\r\n */\r\nexport function unmount( anchorDN: Node = null): void\r\n{\r\n\troot.unmountRoot( anchorDN);\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Provide implementation for the registerCustomAttribute exported function.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nimport {ElmAttr, PropType} from \"../utils/ElmAttr\";\r\n\r\n/**\r\n * Registers custom attribute handler class for the given property name.\r\n * @param propName name of the custom attribute\r\n * @param factory custom attribute class\r\n */\r\nexport function registerCustomAttribute<T>( attrName: string, handlerClass: ICustomAttributeHandlerClass<T>): void\r\n{\r\n\tElmAttr.registerProperty( attrName, { type: PropType.CustomAttr, handlerClass });\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Provide implementation of utility functions.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nimport * as utils from \"../utils/Utils\";\r\n\r\n/**\r\n * Combines arbitrary number of Slice objects merging classes, styles, properties and content\r\n * @param slices Array of Slice objects to merge.\r\n * @returns Resultant Slice object.\r\n */\r\nexport function mergeSlices( ...slices: Slice[]): Slice\r\n{\r\n\treturn utils.mergeSlices( ...slices);\r\n}\r\n\r\n/**\r\n * Combines arbitrary number of Slice objects merging classes, styles, properties and content\r\n * into the given resultant slice.\r\n * @param resSlice Resultant Slice object.\r\n * @param slices Array of Slice objects to merge.\r\n */\r\nexport function mergeSlicesTo( resSlice: Slice, ...slices: Slice[]): void\r\n{\r\n\tutils.mergeSlicesTo( resSlice, ...slices);\r\n}\r\n\r\n/**\r\n * Combines arbitrary number of class properties merging later into the earlier ones. This method\r\n * returns a string or undefined - if all classNames were undefined.\r\n * @param classNames Array of strings or string arrays with class names\r\n * @returns Resultant class string.\r\n */\r\nexport function mergeClasses( ...classNames: (string | string[])[]): string\r\n{\r\n\treturn utils.mergeClasses( ...classNames);\r\n}\r\n\r\n/**\r\n * Combines arbitrary number of style objects merging later into the earlier ones. This method\r\n * always returns an object - even if empty\r\n * @param styles Array of style objects to merge.\r\n */\r\nexport function mergeStyles( ...styles: StylePropType[]): StylePropType\r\n{\r\n\treturn utils.mergeStyles( ...styles);\r\n}\r\n\r\n/**\r\n * Combines arbitrary number of style objects merging later into the first one.\r\n * @param resStyle Resultant style object\r\n * @param styles Array of style objects to merge.\r\n */\r\nexport function mergeStylesTo( resStyle: StylePropType, ...styles: (StylePropType | string)[] ): void\r\n{\r\n\tutils.mergeStylesTo( resStyle, ...styles);\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n// Use type DN to refer to DOM's Node class. The DOM nodes that we are dealing with are\r\n// either of type Element or Text.\r\nexport type DN = Node;\r\n\r\n\r\n\r\n/**\r\n * The VN interface defines properties and methods that are optionally implemented by all\r\n * types of virtual nodes.\r\n */\r\nexport interface VN extends mim.IVNode\r\n{\r\n//////////////////\r\n////////////////////////////////////////\r\n///////////\r\n\r\n\t// Level of nesting at which the node resides relative to the root node.\r\n\tdepth?: number;\r\n\r\n\t// DOM node under which all content of this virtual node is rendered.\r\n\tanchorDN?: DN;\r\n\r\n\t// Node's key. The derived classes set it based on their respective content. A key\r\n\t// can be of any type.\r\n\tkey?: any;\r\n\r\n\t/** Gets node's parent. This is undefined for the top-level (root) nodes. */\r\n\tparent?: VN;\r\n\r\n\t// Reference to the next sibling node or undefined for the last sibling.\r\n\tnext?: VN;\r\n\r\n\t// Reference to the previous sibling node or undefined for the first sibling.\r\n\tprev?: VN;\r\n\r\n\t/** List of sub-nodes. */\r\n\tsubNodes?: VN[];\r\n\r\n\t// Map of keyed sub-nodes - defined only if the number of sub-nodes is greater than 1.\r\n\tkeyedSubNodes?: Map<any,VN>;\r\n\r\n\t/**\r\n\t * Update strategy object that determines different aspects of node behavior\r\n\t * during updates.\r\n\t */\r\n\tupdateStrategy?: mim.UpdateStrategy;\r\n\r\n\t// Returns DOM node corresponding to the virtual node itself (if any) and not to any of its\r\n\t// sub-nodes.\r\n\townDN?: DN;\r\n\r\n\t// Flag indicating that update has been requested but not yet performed. This flag is needed\r\n\t// to prevent trying to add the node to the global map every time the requestUpdate method\r\n\t// is called. \r\n\tupdateRequested: boolean;\r\n\r\n\t// \"Tick number\" during which the node was last updated. If this node's tick number equals\r\n\t// the current tick number maintained by the root node, this indicates that this node was\r\n\t// already updated in this update cycle. This helps prevent double-rendering of a\r\n\t// component if both the component and its parent are updated in the same cycle.\r\n\tlastUpdateTick: number;\r\n\r\n\r\n\r\n\t// Initializes the node by passing the parent node to it. After this, the node knows its\r\n\t// place in the hierarchy and gets access to the root of it - the RootVN object.\r\n\tinit( parent: VN): void;\r\n\r\n\t// Cleans up the node object before it is released.\r\n\tterm(): void;\r\n\r\n\r\n\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////\r\n\t//\r\n\t// Life cycle methods\r\n\t//\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t// Returns content that comprises the children of the node. If the node doesn't have\r\n\t// sub-nodes, null should be returned. If this method is not implemented that means the node\r\n\t// never has children - for example text nodes.\r\n\t// This method is part of the Render phase.\r\n\trender?(): any;\r\n\r\n\t// Initializes internal stuctures of the virtual node. This method is called right after the\r\n\t// node has been constructed.\r\n\t// This method is part of the Render phase.\r\n\twillMount?(): void;\r\n\r\n\t// Clears internal structures of the virtual node. This method is called before the content\r\n\t// of node and all its sub-nodes is removed from the DOM tree.\r\n\t// This method is part of the Commit phase.\r\n\twillUnmount?(): void;\r\n\r\n\t// Creates and returns DOM node corresponding to this virtual node. This method is implemented\r\n\t// only on nodes that have their own DOM nodes.\r\n\t// This method is part of the Commit phase.\r\n\tmount?(): DN;\r\n\r\n\t// Clears DOM node corresponding to this virtual node. This method is implemented only on nodes\r\n\t// that have their own DOM nodes. This method should only release the internally held reference\r\n\t// to the DOM node - the actual removal of the node from DOM is done by the infrastructure.\r\n\t// This method is part of the Commit phase.\r\n\tunmount?(): void;\r\n\r\n\t// Determines whether the update of this node from the given node is possible. The newVN\r\n\t// parameter is guaranteed to point to a VN of the same type as this node. If this method is\r\n\t// not implemented the update is considered possible - e.g. for text nodes.\r\n\t// This method is part of the Render phase.\r\n\tisUpdatePossible?( newVN: VN): boolean;\r\n\r\n\t// Prepares this node to be updated from the given node. This method is invoked only if update\r\n\t// happens as a result of rendering the parent nodes. The newVN parameter is guaranteed to\r\n\t// point to a VN of the same type as this node. The returned object indicates whether children\r\n\t// should be updated and whether the commitUpdate method should be called.\r\n\t// This method is part of the Render phase.\r\n\tprepareUpdate?( newVN: VN): VNUpdateDisp;\r\n\r\n\t// Commits updates made to this node to DOM.\r\n\t// This method is part of the Commit phase.\r\n\tcommitUpdate?( newVN: VN): void;\r\n\r\n\t// Determines whether the node supports handling of errors; that is, exception thrown during\r\n\t// rendering of the node itself and/or its sub-nodes. If this method is not implemented the node\r\n\t// doesn't support error handling.\r\n\t// This method is part of the Render phase.\r\n\tsupportsErrorHandling?(): boolean;\r\n\r\n\t// This method is called after an exception was thrown during rendering of the node itself\r\n\t// and/or its sub-nodes. It returns content comprising the children of the node.\r\n\t// This method is part of the Render phase.\r\n\thandleError?( vnErr: any, path: string[]): void;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The VNUpdateDisp type describes whether certain actions should be performed on the node\r\n// during update. This object is returned from the node's updateFrom method.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class VNUpdateDisp\r\n{\r\n\t// Falg indicatng whether the node has changes that should be applied to the DOM tree. If this\r\n\t// flag is true, then the commitUpdate method will be clled on the node during the Commit\r\n\t// phase.\r\n\tpublic readonly shouldCommit: boolean;\r\n\r\n\t// Falg indicatng whether the sub-nodes should be updated. If this flag is true, then the\r\n\t// node's render method will be immediately called.\r\n\tpublic readonly shouldRender: boolean;\r\n\r\n\tconstructor( shouldCommit: boolean, shouldRender: boolean)\r\n\t{\r\n\t\tthis.shouldCommit = shouldCommit;\r\n\t\tthis.shouldRender = shouldRender;\r\n\t}\r\n\r\n\tpublic static DoCommitDoRender = new VNUpdateDisp( true, true);\r\n\tpublic static DoCommitNoRender = new VNUpdateDisp( true, false);\r\n\tpublic static NoCommitDoRender = new VNUpdateDisp( false, true);\r\n\tpublic static NoCommitNoRender = new VNUpdateDisp( false, false);\r\n\r\n\tpublic static getStockValue( shouldCommit: boolean, shouldRender: boolean)\r\n\t{\r\n\t\treturn shouldCommit\r\n\t\t\t? shouldRender ? VNUpdateDisp.DoCommitDoRender : VNUpdateDisp.DoCommitNoRender\r\n\t\t\t: shouldRender ? VNUpdateDisp.NoCommitDoRender : VNUpdateDisp.NoCommitNoRender;\r\n\t}\r\n};\r\n\r\n\r\n\r\n// Returns the first DOM node defined by either this virtual node or one of its sub-nodes.\r\n// This method is only called on the mounted nodes.\r\nexport function getFirstDN( vn: VN): DN\r\n{\r\n\tif (vn.ownDN)\r\n\t\treturn vn.ownDN;\r\n\telse if (!vn.subNodes)\r\n\t\treturn null;\r\n\r\n\t// recursively call this method on the sub-nodes from first to last until a valid node\r\n\t// is returned\r\n\tlet dn;\r\n\tfor( let svn of vn.subNodes)\r\n\t{\r\n\t\tdn = getFirstDN( svn);\r\n\t\tif (dn)\r\n\t\t\treturn dn;\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n\r\n\r\n// Returns the last DOM node defined by either this virtual node or one of its sub-nodes.\r\n// This method is only called on the mounted nodes.\r\nexport function getLastDN( vn: VN): DN\r\n{\r\n\tif (vn.ownDN)\r\n\t\treturn vn.ownDN;\r\n\telse if (!vn.subNodes)\r\n\t\treturn null;\r\n\r\n\t// recursively call this method on the sub-nodes from last to first until a valid node\r\n\t// is returned\r\n\tlet dn;\r\n\tfor( let i = vn.subNodes.length - 1; i >= 0; i--)\r\n\t{\r\n\t\tdn = getLastDN( vn.subNodes[i]);\r\n\t\tif (dn != null)\r\n\t\t\treturn dn;\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n\r\n\r\n// Returns the list of DOM nodes that are immediate children of this virtual node; that is,\r\n// are NOT children of sub-nodes that have their own DOM node. Never returns null.\r\nexport function getImmediateDNs( vn: VN): DN[]\r\n{\r\n\tlet arr: DN[] = [];\r\n\tcollectImmediateDNs( vn, arr);\r\n\treturn arr;\r\n}\r\n\r\n\r\n\r\n// Collects all DOM nodes that are immediate children of this virtual node (that is,\r\n// are NOT children of sub-nodes that have their own DOM node) into the given array.\r\nfunction collectImmediateDNs( vn: VN, arr: DN[]): void\r\n{\r\n\tif (vn.ownDN)\r\n\t\tarr.push( vn.ownDN);\r\n\telse if (vn.subNodes)\r\n\t{\r\n\t\t// recursively call this method on the sub-nodes from first to last\r\n\t\tfor( let svn of vn.subNodes)\r\n\t\t\tcollectImmediateDNs( svn, arr);\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Finds the first DOM node in the tree of virtual nodes that comes after our node that is a\r\n// child of our own anchor element. We use it as a node before which to insert/move nodes of\r\n// our sub-nodes during the reconciliation process. The algorithm first goes to the next\r\n// siblings of our node and then to the next siblings of our parent node recursively. It stops\r\n// when we either find a DOM node (then it is returned) or find a different anchor element\r\n// (then null is returned). This method is called before the reconciliation process for our\r\n// sub-nodes starts and, therefore, it only traverses mounted nodes.\r\nexport function getNextDNUnderSameAnchorDN( vn: VN, anchorDN: DN): DN\r\n{\r\n\t// check if we have sibling DOM nodes after our last sub-node - that might be elements\r\n\t// not controlled by our component.\r\n\tif (vn.subNodes && vn.subNodes.length > 0)\r\n\t{\r\n\t\tlet dn = getLastDN( vn.subNodes[vn.subNodes.length - 1]);\r\n\t\tif (dn)\r\n\t\t{\r\n\t\t\tlet nextSibling = dn.nextSibling;\r\n\t\t\tif (nextSibling !== null)\r\n\t\t\t\treturn nextSibling;\r\n\t\t}\r\n\t}\r\n\r\n\t// loop over our next siblings\r\n\tfor( let nvn = vn.next; nvn !== undefined; nvn = nvn.next)\r\n\t{\r\n\t\tif (!nvn.anchorDN)\r\n\t\t\treturn null;\r\n\r\n\t\t// note that getLastDN call traverses the hierarchy of nodes. Note also that it\r\n\t\t// cannot find a node under a different anchor element because the first different\r\n\t\t// anchor element will be returned as a wanted node.\r\n\t\tconst dn = getLastDN( nvn);\r\n\t\tif (dn)\r\n\t\t\treturn dn;\r\n\t}\r\n\r\n\t// recurse to our parent if exists\r\n\treturn vn.parent && vn.parent.anchorDN === anchorDN ? getNextDNUnderSameAnchorDN( vn.parent, anchorDN) : null;\r\n}\r\n\r\n\r\n\r\n// Returns array of node names starting with this node and up until the top-level node.\r\nexport function getVNPath( vn: VN): string[]\r\n{\r\n\tlet depth = vn.depth;\r\n\tlet path = Array<string>( depth);\r\n\tfor( let i = 0, nvn: VN = vn; i < depth; i++, nvn = nvn.parent)\r\n\t{\r\n\t\tpath[i] = nvn.name;\r\n\t}\r\n\r\n\treturn path;\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {VN, DN, getVNPath} from \"./VN\"\r\nimport {requestNodeUpdate, scheduleFuncCall} from \"./Scheduler\"\r\nimport {notifyServicePublished, notifyServiceUnpublished, notifyServiceSubscribed, notifyServiceUnsubscribed} from \"./PubSub\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n// Use type DN to refer to DOM's Node class. The DOM nodes that we are dealing with are\r\n// either of type Element or Text.\r\nexport type DN = Node;\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The VNBase class is a base class for all types of virtual nodes.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport abstract class VNBase implements VN\r\n{\r\n//////////////////\r\n/////////////////////////////////////////////////////\r\n///////////\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic abstract get name(): string;\r\n\r\n\t// Node's type.\r\n\tpublic type: mim.VNType;\r\n\r\n\t// Parent node. This is null for the top-level (root) nodes.\r\n\tpublic parent: VNBase;\r\n\r\n\t// Level of nesting at which the node resides relative to the root node.\r\n\tpublic depth: number;\r\n\r\n\t// DOM node under which all content of this virtual node is rendered.\r\n\tpublic anchorDN: DN;\r\n\r\n\t// Reference to the next sibling node or undefined for the last sibling.\r\n\tpublic next: VNBase;\r\n\r\n\t// Reference to the previous sibling node or undefined for the first sibling.\r\n\tpublic prev: VNBase;\r\n\r\n\t// List of sub-nodes - both keyed and unkeyed - defined only if there are some sub-nodes.\r\n\tpublic subNodes: VNBase[];\r\n\r\n\t// Map of keyed sub-nodes - defined only if the number of sub-nodes is greater than 1.\r\n\tpublic keyedSubNodes: Map<any,VNBase>;\r\n\r\n\t// Flag indicating that update has been requested but not yet performed. This flag is needed\r\n\t// to prevent trying to add the node to the global map every time the requestUpdate method\r\n\t// is called. \r\n\tpublic updateRequested: boolean;\r\n\r\n\t// \"Tick number\" during which the node was last updated. If this node's tick number equals\r\n\t// the current tick number maintained by the root node, this indicates that this node was\r\n\t// already updated in this update cycle. This helps prevent double-rendering of a\r\n\t// component if both the component and its parent are updated in the same cycle.\r\n\tpublic lastUpdateTick: number;\r\n\r\n\t// // Component that created this node or null if created not by a component (e.g. directly in\r\n\t// // mim.mount).\r\n\t// private _creator: mim.IClassCompVN;\r\n\t// public get creator(): mim.IClassCompVN\r\n\t// {\r\n\t// \tif (this._creator === undefined)\r\n\t// \t{\r\n\t// \t\t// go up the parent chain\r\n\t// \t\tlet ancestor = this.parent;\r\n\t// \t\twhile( ancestor)\r\n\t// \t\t{\r\n\t// \t\t\tif (ancestor.type === mim.VNType.ClassComp || ancestor.type == mim.VNType.InstanceComp)\r\n\t// \t\t}\r\n\t// \t}\r\n\r\n\t// \treturn this._creator;\r\n\t// }\r\n\r\n\r\n\r\n\t// Initializes the node by passing the parent node to it. After this, the node knows its\r\n\t// place in the hierarchy and gets access to the root of it - the RootVN object.\r\n\tpublic init( parent: VNBase): void\r\n\t{\r\n\t\tthis.parent = parent;\r\n\t\tthis.depth = this.parent ? this.parent.depth + 1 : 0;\r\n\t}\r\n\r\n\r\n\r\n\t// Cleans up the node object before it is released.\r\n\tpublic term(): void\r\n\t{\r\n\t\t// remove information about any published and subscribed services\r\n\t\tif (this.publishedServices !== undefined)\r\n\t\t{\r\n\t\t\tthis.publishedServices.forEach( (service, id) => notifyServiceUnpublished( id, this));\r\n\t\t\tthis.publishedServices.clear();\r\n\t\t}\r\n\r\n\t\tif (this.subscribedServices !== undefined)\r\n\t\t{\r\n\t\t\tthis.subscribedServices.forEach( (info, id) => { notifyServiceUnsubscribed( id, this); });\r\n\t\t\tthis.subscribedServices.clear();\r\n\t\t}\r\n\r\n\t\t// // disconnect the node from its siblings (if any)\r\n\t\t// if (this.next !== undefined)\r\n\t\t// \tthis.next.prev = undefined;\r\n\r\n\t\t// if (this.prev !== undefined)\r\n\t\t// \tthis.prev.next = undefined;\r\n\r\n\t\tthis.next = undefined;\r\n\t\tthis.prev = undefined;\r\n\t\tthis.subNodes = undefined;\r\n\t\tthis.keyedSubNodes = undefined;\r\n\t\tthis.depth = undefined;\r\n\t\tthis.parent = undefined;\r\n\t}\r\n\r\n\r\n\r\n\t// Schedules an update for this node.\r\n\tpublic requestUpdate(): void\r\n\t{\r\n\t\tif (!this.updateRequested)\r\n\t\t{\r\n\t\t\trequestNodeUpdate( this);\r\n\t\t\tthis.updateRequested = true;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Schedules to call the given function either before or after all the scheduled components\r\n\t// have been updated.\r\n\tpublic scheduleCall( func: () => void, beforeUpdate: boolean = false): void\r\n\t{\r\n\t\tscheduleFuncCall( func, beforeUpdate);\r\n\t}\r\n\r\n\r\n\r\n\t// Registers an object of any type as a service with the given ID that will be available for\r\n\t// consumption by descendant nodes.\r\n\tpublic publishService( id: string, service: any): void\r\n\t{\r\n\t\tif (this.publishedServices === undefined)\r\n\t\t\tthis.publishedServices = new Map<string,any>();\r\n\r\n\t\tlet existinService: any = this.publishedServices.get( id);\r\n\t\tif (existinService !== service)\r\n\t\t{\r\n\t\t\tthis.publishedServices.set( id, service);\r\n\t\t\tnotifyServicePublished( id, this);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Unregisters a service with the given ID.\r\n\tpublic unpublishService( id: string): void\r\n\t{\r\n\t\tif (this.publishedServices === undefined)\r\n\t\t\treturn;\r\n\r\n\t\tthis.publishedServices.delete( id);\r\n\t\tnotifyServiceUnpublished( id, this);\r\n\r\n\t\tif (this.publishedServices.size === 0)\r\n\t\t\tthis.publishedServices = undefined;\r\n\t}\r\n\r\n\r\n\r\n\t// Subscribes for a service with the given ID. If the service with the given ID is registered\r\n\t// by one of the ancestor nodes, the passed Ref object will reference it; otherwise,\r\n\t// the Ref object will be set to the defaultValue (if specified) or will remain undefined.\r\n\t// Whenever the value of the service that is registered by a closest ancestor node is\r\n\t// changed, the Ref object will receive the new value.\r\n\tpublic subscribeService( id: string, ref: mim.RefPropType, defaultService?: any, useSelf?: boolean): void\r\n\t{\r\n\t\tif (this.subscribedServices === undefined)\r\n\t\t\tthis.subscribedServices = new Map<string,VNSubscribedServiceInfo>();\r\n\r\n\t\tlet info = new VNSubscribedServiceInfo();\r\n\t\tinfo.ref = ref;\r\n\t\tinfo.defaultService = defaultService;\r\n\t\tinfo.useSelf = useSelf ? true : false;\r\n\r\n\t\tthis.subscribedServices.set( id, info);\r\n\t\tnotifyServiceSubscribed( id, this);\r\n\t\tmim.setRef( ref, this.getService( id, defaultService));\r\n}\r\n\r\n\r\n\r\n\t// Unsubscribes from a service with the given ID. The Ref object that was used to subscribe,\r\n\t// will be set to undefined.\r\n\tpublic unsubscribeService( id: string): void\r\n\t{\r\n\t\tif (this.subscribedServices === undefined)\r\n\t\t\treturn;\r\n\r\n\t\tlet info = this.subscribedServices.get( id);\r\n\t\tif (info === undefined)\r\n\t\t\treturn;\r\n\r\n\t\tmim.setRef( info.ref, undefined);\r\n\t\tthis.subscribedServices.delete( id);\r\n\t\tnotifyServiceUnsubscribed( id, this);\r\n\r\n\t\tif (this.subscribedServices.size === 0)\r\n\t\t\tthis.subscribedServices = undefined;\r\n\t}\r\n\r\n\r\n\r\n\t// Retrieves the value for a service with the given ID registered by a closest ancestor\r\n\t// node or the default value if none of the ancestor nodes registered a service with\r\n\t// this ID. This method doesn't establish a subscription and only reflects the current state.\r\n\tpublic getService( id: string, defaultService?: any, useSelf?: boolean): any\r\n\t{\r\n\t\tlet service = this.findService( id, useSelf);\r\n\t\treturn service !== undefined ? service : defaultService;\r\n\t}\r\n\r\n\r\n\r\n\t// Goes up the chain of nodes looking for a published service with the given ID. Returns\r\n\t// undefined if the service is not found. Note that null might be a valid value.\r\n\tprivate findService( id: string, useSelf?: boolean): any\r\n\t{\r\n\t\tif (useSelf)\r\n\t\t{\r\n\t\t\tif (this.publishedServices !== undefined)\r\n\t\t\t{\r\n\t\t\t\tlet service = this.publishedServices.get( id);\r\n\t\t\t\tif (service !== undefined)\r\n\t\t\t\t\treturn service;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// go up the chain; note that we don't pass the useSelf parameter on.\r\n\t\treturn this.parent ? this.parent.findService( id, true) : undefined;\r\n\t}\r\n\r\n\r\n\r\n\t// Notifies the node that publication information about the given service (to which the node\r\n\t// has previously subscribed) has changed.\r\n\tpublic notifyServiceChanged( id: string): void\r\n\t{\r\n\t\tif (this.subscribedServices === undefined)\r\n\t\t\treturn;\r\n\r\n\t\tlet info = this.subscribedServices.get( id);\r\n\t\tif (info === undefined)\r\n\t\t\treturn;\r\n\r\n\t\tmim.setRef( info.ref, this.getService( id, info.defaultService));\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Creates a wrapper function with the same signature as the given callback so that if the original\r\n\t * callback throws an exception, it is processed by the Mimble error handling mechanism so that the\r\n\t * exception bubles from this virtual node up the hierarchy until a node/component that knows\r\n\t * to handle errors is found.\r\n\t * \r\n\t * This function should be called by the code that is not part of any component but still has access\r\n\t * to the IVNode object; for example, custom attribute handlers. Components that derive from the\r\n\t * mim.Component class should use the wrapCallback method of the mim.Component class.\r\n\t * \r\n\t * @param callback \r\n\t */\r\n\tpublic wrapCallback<T>( callback: T, that?: any): T\r\n\t{\r\n\t\t// if (!that && (callback as any).boundable === true)\r\n\t\t// \tthat = undefined;\r\n\r\n\t\treturn CallbackWrapper.bind( this, that, callback);\r\n\t}\r\n\r\n\r\n\r\n\t// Map of service IDs to service objects published by this node.\r\n\tprivate publishedServices: Map<string,any>;\r\n\r\n\t// Map of service IDs to objects constituting subscriptions made by this node.\r\n\tprivate subscribedServices: Map<string,VNSubscribedServiceInfo>;\r\n}\r\n\r\n\r\n\r\n/**\r\n * The CallbackWrapper function is used to wrap a callback in order to catch exceptions from the\r\n * callback and pass it to the \"StdErrorHandling\" service. The function is bound to two parameters:\r\n * a virtual node (accessed as `this`) and the original callback (accessed as the first element\r\n * from the `arguments` array). The rest of parameters in the `arguments` array are passed to the\r\n * original callback and the value returned by the callback is returned from the wrapper.\r\n */\r\nfunction CallbackWrapper(): any\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet [that, orgCallback, ...rest] = arguments;\r\n\t\treturn that ? orgCallback.apply( that, rest) : orgCallback( ...rest);\r\n\t}\r\n\tcatch( err)\r\n\t{\r\n\t\tlet errorService = this.findService( \"StdErrorHandling\") as mim.IErrorHandlingService;\r\n\t\tif (errorService)\r\n\t\t\terrorService.reportError( err, getVNPath( this));\r\n\t\telse\r\n\t\t\tthrow err;\r\n\t}\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The VNSubscribedServiceInfo class keeps information about a subscription of a node to a service.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass VNSubscribedServiceInfo\r\n{\r\n\t// Reference that will be filled in with the service value\r\n\tref: mim.RefPropType<any>;\r\n\r\n\t// Default value of the service that is used if none of the ancestor nodes publishes the\r\n\t// service\r\n\tdefaultService: any;\r\n\r\n\t// Flag indicating whether a node can subscribe to a service that it implements itself. This\r\n\t// is useful in case where a service that is implemented by a component can chain to a service\r\n\t// implemented by an ancestor component.\r\n\tuseSelf: boolean;\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {VN} from \"./VN\"\r\nimport {VNBase} from \"./VNBase\"\r\nimport {IndependentCompVN} from \"./IndependentCompVN\"\r\nimport {ManagedCompVN} from \"./ManagedCompVN\"\r\nimport {FuncVN} from \"./FuncVN\"\r\nimport {ElmVN} from \"./ElmVN\"\r\nimport {TextVN} from \"./TextVN\"\r\n\r\n\r\n\r\n// Creates either a single virtual node or an array of virtual nodes from the given content.\r\n// For all types of contents other than an array, the returned value is a single VN. If the input\r\n// content is an array, then a VN is created for each of the array elements. Since array elements\r\n// might also be arrays, the process is recursive.\r\nexport function createNodesFromContent( content: any): VN | VN[]\r\n{\r\n\tif (content === null || content === undefined || content === false || typeof content === \"function\")\r\n\t\treturn null;\r\n\telse if (typeof content === \"string\")\r\n\t\treturn new TextVN( content);\r\n\telse if (content instanceof VNBase)\r\n\t\treturn content;\r\n\telse if (typeof content.render === \"function\")\r\n\t{\r\n\t\t// if the component (this can only be an Instance component) is already attached to VN, add\r\n\t\t// this existing VN; otherwise create a new one.\r\n\t\treturn (content as mim.IComponent).vn\r\n\t\t\t\t\t\t? (content as mim.IComponent).vn as VN\r\n\t\t\t\t\t\t: new IndependentCompVN( content as mim.IComponent);\r\n\t}\r\n\telse if (Array.isArray( content))\r\n\t\treturn createNodesFromArray( content);\r\n\telse if (content instanceof Promise)\r\n\t\tthrow content;\r\n\telse\r\n\t\treturn new TextVN( content.toString());\r\n}\r\n\r\n\r\n\r\n// Creates an array of virtual nodes from the given content. Calls the createNodesFromContent and\r\n// if it returns a single node, wraps it in an array.\r\nexport function createVNChainFromContent( content: any): VN[]\r\n{\r\n\tlet nodes = createNodesFromContent( content);\r\n\tif (!nodes)\r\n\t\treturn null;\r\n\telse if (Array.isArray(nodes))\r\n\t\treturn nodes;\r\n\telse\r\n\t\treturn [nodes];\r\n}\r\n\r\n\r\n\r\n// Creates a chain of virtual nodes from the data provided by the TypeScript's JSX parser.\r\nexport function createNodesFromJSX( tag: any, props: any, children: any[]): VN | VN[]\r\n{\r\n\tif (typeof tag === \"string\")\r\n\t\treturn new ElmVN( tag as string, props, children);\r\n\telse if (tag === mim.Fragment)\r\n\t\treturn createNodesFromArray( children);\r\n\telse if (typeof tag === \"function\")\r\n\t{\r\n\t\t// children parameter is always an array. A component can specify that its children are\r\n\t\t// an array of a certain type, e.g. class A extends mim.Component<{},T[]>. In this case\r\n\t\t// there are two ways to specify children in JSX that would be accepted by the TypeScript\r\n\t\t// compiler:\r\n\t\t//\t1) <A>{t1}{t2}</A>. In this case, children will be [t1, t2] (as expected by A).\r\n\t\t//\t2) <A>{[t1, t2]}</A>. In this case, children will be [[t1,t2]] (as NOT expected by A).\r\n\t\t//\t\tThis looks like a TypeScript bug.\r\n\t\t// The realChildren variable accommodates both cases.\r\n\t\tlet realChildren = children.length === 1 && Array.isArray( children[0]) ? children[0] : children;\r\n\t\tif (typeof tag.prototype.render === \"function\")\r\n\t\t\treturn new ManagedCompVN( tag as mim.IComponentClass, props, realChildren);\r\n\t\telse\r\n\t\t\treturn new FuncVN( tag as mim.FuncCompType, props, realChildren);\r\n\t}\r\n\r\n//////////////\r\n/////\r\n/////////////////////////////////////////////////////////////////////\r\n///////////\r\n}\r\n\r\n\r\n\r\n// Creates array of virtual nodes from the given array of items.\r\nfunction createNodesFromArray( arr: any[]): VN[]\r\n{\r\n\tif (arr.length === 0)\r\n\t\treturn null;\r\n\r\n\tlet nodes: VN[] = [];\r\n\tfor( let item of arr)\r\n\t{\r\n\t\tlet itemNodes = createNodesFromContent( item);\r\n\t\tif (itemNodes === null)\r\n\t\t\tcontinue;\r\n\t\telse if (Array.isArray( itemNodes))\r\n\t\t{\r\n\t\t\tfor( let vn of itemNodes)\r\n\t\t\t\tnodes.push( vn);\r\n\t\t}\r\n\t\telse\r\n\t\t\tnodes.push( itemNodes);\r\n\t}\r\n\r\n\treturn nodes.length > 0 ? nodes : null;\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {DN, VN, getFirstDN, getLastDN, getImmediateDNs, getNextDNUnderSameAnchorDN, getVNPath} from \"./VN\"\r\nimport {createVNChainFromContent} from \"./ContentFuncs\"\r\nimport {VNDispAction, VNDisp, VNDispGroup} from \"./VNDisp\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// State of the scheduler indicating in what phase of the update cycle we currently reside.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nenum SchedulerState\r\n{\r\n\t// The scheduler is not within the update cycle\r\n\tIdle = 0,\r\n\r\n\t// The scheduler is executing functions before updating nodes\r\n\tBeforeUpdate,\r\n\r\n\t// The scheduler is updating nodes\r\n\tUpdate,\r\n\r\n\t// The scheduler is executing functions after updating nodes\r\n\tAfterUpdate,\r\n}\r\n\r\n\r\n\r\n// Map of nodes that should be updated on the next UI cycle. We use Map in order to not include\r\n// the same node more than once - which can happen if the node's requestUpdate method is called\r\n// more than once during a single run (e.g. during event processing). The value mapped to the\r\n// node determines the operation to be performed:\r\n//\t- undefined - the node will be updated\r\n//\t- null - the node will be deleted from its parent\r\n//\t- anything else - the node will be replaced with this new content\r\nlet s_vnsScheduledForUpdate = new Set<VN>();\r\n\r\n// Set of functions that have been scheduled to be called upon a new animation frame before\r\n// components scheduled for update are updated.\r\nlet s_callsScheduledBeforeUpdate = new Set<mim.ScheduledFuncType>();\r\n\r\n// Set of functions that have been scheduled to be called upon a new animation frame after\r\n// components scheduled for update are updated.\r\nlet s_callsScheduledAfterUpdate = new Set<mim.ScheduledFuncType>();\r\n\r\n// Handle of the animation frame request (in case it should be canceled).\r\nlet s_scheduledFrameHandle: number = 0;\r\n\r\n// State of the scheduler.\r\nlet s_schedulerState: SchedulerState = SchedulerState.Idle;\r\n\r\n// Number that serves as a unique ID of an update cycle. Each update cycle the root node\r\n// increments this number. Each node being updated in this cycle is assigned this number.\r\n// This helps prevent double-rendering of when both a component and its parent are\r\n// updated in the same cycle.\r\nlet s_currentTick: number = 0;\r\n\r\n// Node currently being processed. During creation and updating process, this value is set\r\n// every time we recurse into sub-nodes and restored when we return back to the node. If\r\n// during creation or updating process an exception is thrown and is caught by some upper\r\n// level node, this value will still point at the node that caused the exception.\r\nexport let s_currentVN: VN = null;\r\n\r\n\r\n\r\n// Callback that is called on a new UI cycle when there is a need to update UI components\r\nexport function updateNodeSync( vn: VN): void\r\n{\r\n\t// increment tick number.\r\n\ts_currentTick++;\r\n\r\n//////////////////\r\n////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////\r\n///////////\r\n\r\n\tlet vns: VN[][] = new Array(1);\r\n\tvns[0] = [vn];\r\n\r\n\ts_schedulerState = SchedulerState.Update;\r\n\tperformCommitPhase( performRenderPhase( vns));\r\n\r\n//////////////////\r\n//////////////////////////////////\r\n/////////////////////////////\r\n///////////\r\n\r\n\ts_schedulerState = SchedulerState.Idle;\r\n};\r\n\r\n\r\n\r\n// Schedules an update for the given node.\r\nexport function requestNodeUpdate( vn: VN): void\r\n{\r\n\tif (!vn.anchorDN)\r\n\t\tconsole.warn( `Update requested for virtual node '${getVNPath(vn).join(\"->\")}' that doesn't have anchor DOM node`)\r\n\r\n\t// add this node to the map of nodes for which either update or replacement or\r\n\t// deletion is scheduled. Note that a node will only be present once in the map no\r\n\t// matter how many times it calls requestUpdate().\r\n\ts_vnsScheduledForUpdate.add( vn);\r\n\r\n\t// the update is scheduled in the next cycle unless the request is made during a\r\n\t// \"before update\" function execution.\r\n\tif (s_schedulerState !== SchedulerState.BeforeUpdate)\r\n\t\trequestFrameIfNeeded();\r\n}\r\n\r\n\r\n\r\n// Schedules to call the given function either before or after all the scheduled components\r\n// have been updated.\r\nexport function scheduleFuncCall( func: mim.ScheduledFuncType, beforeUpdate: boolean = false): void\r\n{\r\n\tif (!func)\r\n\t\treturn;\r\n\r\n\tif (beforeUpdate)\r\n\t{\r\n\t\ts_callsScheduledBeforeUpdate.add( func);\r\n\r\n\t\t// a \"before update\" function is always scheduled in the next frame even if the\r\n\t\t// call is made from another \"before update\" function.\r\n\t\trequestFrameIfNeeded();\r\n\t}\r\n\telse\r\n\t{\r\n\t\ts_callsScheduledAfterUpdate.add( func);\r\n\r\n\t\t// an \"after update\" function is scheduled in the next cycle unless the request is made\r\n\t\t// either from a \"before update\" function execution or during a node update.\r\n\t\tif (s_schedulerState !== SchedulerState.BeforeUpdate && s_schedulerState !== SchedulerState.Update)\r\n\t\t\trequestFrameIfNeeded();\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Determines whether the call to requestAnimationFrame should be made or the frame has already\r\n// been scheduled.\r\nfunction requestFrameIfNeeded(): void\r\n{\r\n\tif (s_scheduledFrameHandle === 0)\r\n\t\ts_scheduledFrameHandle = requestAnimationFrame( onScheduledFrame);\r\n}\r\n\r\n\r\n\r\n// Callback that is called on a new UI cycle when there is a need to update UI components\r\nlet onScheduledFrame = (): void =>\r\n{\r\n\t// clear the scheduled frame handle so that new update or replacement requests will\r\n\t// schedule a new frame.\r\n\ts_scheduledFrameHandle = 0;\r\n\r\n\t// increment tick number.\r\n\ts_currentTick++;\r\n\r\n\t// call functions scheduled to be invoked before updating components. If this function\r\n\t// calls the requestUpdate method or schedules a function to be invoked after updates,\r\n\t// they will be executed in this cycle. However, if it schedules a function to be invoked\r\n\t// after updates, it will be executed in the next cycle.\r\n\tif (s_callsScheduledBeforeUpdate.size > 0)\r\n\t{\r\n\t\ts_schedulerState = SchedulerState.BeforeUpdate;\r\n\t\tlet callsScheduledBeforeUpdate = s_callsScheduledBeforeUpdate;\r\n\t\ts_callsScheduledBeforeUpdate = new Set<mim.ScheduledFuncType>();\r\n\t\tcallScheduledFunctions( callsScheduledBeforeUpdate, \"before\");\r\n\t}\r\n\r\n\tif (s_vnsScheduledForUpdate.size > 0)\r\n\t{\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////////\r\n////////////\r\n\r\n\t\t// remember the internal set of nodes and re-create it so that it is ready for new\r\n\t\t// update requests. Arrange scheduled nodes by their nesting depths and perform updates.\r\n\t\ts_schedulerState = SchedulerState.Update;\r\n\t\tlet vnsScheduledForUpdate = s_vnsScheduledForUpdate;\r\n\t\ts_vnsScheduledForUpdate = new Set<VN>();\r\n\t\tperformCommitPhase( performRenderPhase( arrangeNodesByDepth( vnsScheduledForUpdate)));\r\n\r\n///////////////////\r\n///////////////////////////////////\r\n//////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\t// call functions scheduled to be invoked after updating components\r\n\tif (s_callsScheduledAfterUpdate.size > 0)\r\n\t{\r\n\t\ts_schedulerState = SchedulerState.AfterUpdate;\r\n\t\tlet callsScheduledAfterUpdate = s_callsScheduledAfterUpdate;\r\n\t\ts_callsScheduledAfterUpdate = new Set<mim.ScheduledFuncType>();\r\n\t\tcallScheduledFunctions( callsScheduledAfterUpdate, \"after\");\r\n\t}\r\n\r\n\ts_schedulerState = SchedulerState.Idle;\r\n};\r\n\r\n\r\n\r\n// Arranges the scheduled nodes by their nesting depths so that we update \"upper\" nodes before\r\n// the lower ones. This can help avoid two conditions:\r\n//\t- rendering a child component twice: first because it called updateMe, and second\r\n//\t\tbecause its parent was also updated.\r\n//\t- unnecessary rendering a child component before it is removed by the parent\r\n// We allocate contiguous array where indices correspond to depth. Each element in this\r\n// array will either be undefined or contain an array of nodes at this depth.\r\nfunction arrangeNodesByDepth( vnsScheduledForUpdate: Set<VN>): VN[][]\r\n{\r\n/////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n///////////////////////\r\n///////////\r\n\r\n\t// create a sparse array of certain reasonable size. If we have depths greater than this,\r\n\t// the array will grow automatically (although it is less performant it is still acceptable).\r\n\tlet vnsByDepth: VN[][] = new Array<VN[]>(100);\r\n\tvnsScheduledForUpdate.forEach( (vn: VN) =>\r\n\t{\r\n\t\tlet arr = vnsByDepth[vn.depth];\r\n\t\tif (!arr)\r\n\t\t{\r\n\t\t\tarr = [];\r\n\t\t\tvnsByDepth[vn.depth] = arr;\r\n\t\t}\r\n\r\n\t\tarr.push(vn);\r\n\t});\r\n\r\n/////////////////////\r\n//////////////////////////\r\n///////////\r\n\r\n\treturn vnsByDepth;\r\n}\r\n\r\n// Performs rendering phase for all components scheduled for update and recursively for their\r\n// sub-nodes where necessary. Returns array of VNDisp structures for each updated node.\r\nfunction performRenderPhase( vnsByDepth: VN[][]): VNDisp[]\r\n{\r\n\tlet updatedNodeDisps: VNDisp[] = [];\r\n\r\n\t// iteration over the sparse array skips the holes.\r\n\tlet disp: VNDisp;\r\n\tvnsByDepth.forEach( (vns: VN[]) => { vns.forEach( (vn: VN) =>\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// clear the flag that update has been requested for the node\r\n\t\t\tvn.updateRequested = false;\r\n\t\t\t\r\n\t\t\t// if the component was already updated in this cycle, don't update it again\r\n\t\t\tif (vn.lastUpdateTick === s_currentTick)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tdisp = new VNDisp( vn, VNDispAction.Unknown, vn);\r\n\t\t\tupdateVirtual( disp);\r\n\t\t\tupdatedNodeDisps.push( disp);\r\n\t\t}\r\n\t\tcatch( err)\r\n\t\t{\r\n\t\t\t// find the nearest error handling service. If nobody else, it is implemented\r\n\t\t\t// by the RootVN object.\r\n\t\t\tlet errorService: mim.IErrorHandlingService = vn.getService( \"StdErrorHandling\", undefined, false);\r\n\t\t\tif (errorService)\r\n\t\t\t\terrorService.reportError( err, s_currentVN ? getVNPath( s_currentVN) : null);\r\n\t\t\telse\r\n\t\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\ts_currentVN = null;\r\n\t})});\r\n\r\n\treturn updatedNodeDisps;\r\n}\r\n\r\n\r\n\r\n// Performs the commit phase for all components scheduled for update and recursively for their\r\n// sub-nodes where necessary. The Commit phase consists of updating DOM and calling life-cycle\r\n// methods didMount, didUpdate and willUnmount.\r\nfunction performCommitPhase( updatedNodeDisps: VNDisp[]): void\r\n{\r\n\t// we don't unticipate any exceptions here because we don't invoke 3rd-party code here.\r\n\tupdatedNodeDisps.forEach( (disp: VNDisp) =>\r\n\t{\r\n\t\tupdatePhysical( disp);\r\n\t});\r\n}\r\n\r\n\r\n\r\n// Call functions scheduled before or after update cycle.\r\nfunction callScheduledFunctions( funcs: Set<()=>void>, beforeOrAfter: string)\r\n{\r\n\tfuncs.forEach( (func) =>\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tfunc();\r\n\t\t}\r\n\t\tcatch( err)\r\n\t\t{\r\n\t\t\tconsole.error( `Exception while invoking function ${beforeOrAfter} updating components\\n`, err);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n\r\n// Recursively creates and renders this node and its sub-nodes. This method is invoked\r\n// when a node is first mounted. If an exception is thrown during the execution of this\r\n// method (which can be only from components' setSite or render methods),\r\n// the component is asked to handle the error. If the component handles the error, the\r\n// content returned from the error handling method is rendered; otherwise, the exception\r\n// is re-thrown. Thus, the exception is propagated up until it is handled by a node that\r\n// handles it or up to the root node.\r\nfunction createVirtual( vn: VN, parent: VN): void\r\n{\r\n\tvn.init( parent);\r\n\r\n\t// set essential node parameters.\r\n\tvn.parent = parent;\r\n\tvn.depth = vn.parent ? vn.parent.depth + 1 : 0;\r\n\r\n\t// keep track of the node that is being currently processed.\r\n\tlet currentVN = vn;\r\n\ts_currentVN = currentVN;\r\n\r\n\tif (vn.willMount)\r\n\t{\r\n//////////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tvn.willMount();\r\n\t\t}\r\n\t\tcatch( err)\r\n\t\t{\r\n\t\t\tif (vn.supportsErrorHandling && vn.supportsErrorHandling())\r\n\t\t\t{\r\n////////////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////////\r\n\r\n\t\t\t\t// let the node handle its own error and re-render\r\n\t\t\t\tvn.handleError( err, getVNPath( s_currentVN));\r\n\t\t\t\tvn.willMount();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\t// if the node doesn't implement `render`, the node never has any sub-nodes (e.g. text nodes)\r\n\tif (vn.render)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tcreateSubNodesVirtual( vn);\r\n\t\t}\r\n\t\tcatch( err)\r\n\t\t{\r\n\t\t\tif (vn.supportsErrorHandling && vn.supportsErrorHandling())\r\n\t\t\t{\r\n////////////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////////\r\n\r\n\t\t\t\t// let the node handle its own error and re-render\r\n\t\t\t\tvn.handleError( err, getVNPath( s_currentVN));\r\n\t\t\t\tcreateSubNodesVirtual( vn);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\t// restore pointer to the currently being processed node after processing its sub-nodes.\r\n\t// If this node doesn't support error handling and an exception is thrown either by this\r\n\t// node or by one of its sub-nodes, this line is not executed and thus, s_currentVN\r\n\t// will point to our node when the exception is caught.\r\n\ts_currentVN = currentVN;\r\n}\r\n\r\n\r\n\r\n// Performs creation and initial rendering on the sub-nodes of our node.\r\nfunction createSubNodesVirtual( vn: VN): void\r\n{\r\n\t// this method is only invoked if the node has the render function\r\n\tvn.subNodes = createVNChainFromContent( vn.render());\r\n\tif (vn.subNodes)\r\n\t{\r\n\t\tif (vn.subNodes.length > 1)\r\n\t\t\tvn.keyedSubNodes = new Map<any,VN>();\r\n\r\n\t\tlet prevVN: VN;\r\n\t\tfor( let svn of vn.subNodes)\r\n\t\t{\r\n\t\t\tcreateVirtual( svn, vn);\r\n\r\n\t\t\tif (vn.keyedSubNodes !== undefined && svn.key !== undefined)\r\n\t\t\t\tvn.keyedSubNodes.set( svn.key, svn);\r\n\r\n\t\t\tif (prevVN)\r\n\t\t\t{\r\n\t\t\t\tprevVN.next = svn;\r\n\t\t\t\tsvn.prev = prevVN;\r\n\t\t\t}\r\n\r\n\t\t\tprevVN = svn;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Recursively creates DOM nodes for this VN and its sub-nodes.\r\nfunction createPhysical( vn: VN, anchorDN: DN, beforeDN: DN)\r\n{\r\n\t// remember the anchor node\r\n\tvn.anchorDN = anchorDN;\r\n\r\n/////////////////////\r\n////////////////////////////////////////////////////////////////\r\n///////////\r\n\tlet ownDN = vn.mount ? vn.mount() : undefined;\r\n\r\n\t// if we have our own DOM node, add it under the anchor node\r\n\tif (ownDN)\r\n\t\tvn.anchorDN.insertBefore( ownDN, beforeDN);\r\n\r\n\t// if the node has sub-nodes, add DOM nodes for them. If the virtual node has its own\r\n\t// DOM node use it as an anchor for the sub-nodes.\r\n\tif (vn.subNodes)\r\n\t{\r\n\t\t// determine what nodes to use as anchor and \"before\" for the sub-nodes\r\n\t\tlet newAnchorDN = ownDN ? ownDN : anchorDN;\r\n\t\tlet newBeforeDN = ownDN ? null : beforeDN;\r\n\r\n\t\t// mount all sub-nodes\r\n\t\tfor( let svn of vn.subNodes)\r\n\t\t\tcreatePhysical( svn, newAnchorDN, newBeforeDN);\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Recursively calls willUnmount on this VN and its sub-nodes.\r\nfunction preDestroy( vn: VN)\r\n{\r\n\tif (vn.subNodes)\r\n\t{\r\n\t\tfor( let svn of vn.subNodes)\r\n\t\t\tpreDestroy( svn);\r\n\t}\r\n\r\n\tif (vn.willUnmount)\r\n\t{\r\n//////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tvn.willUnmount();\r\n\t\t}\r\n\t\tcatch( err)\r\n\t\t{\r\n\t\t\tconsole.error( `Node ${vn.name} threw exception '${err.message}' in willUnmount`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Recursively removes DOM nodes corresponding to this VN and its sub-nodes.\r\nfunction destroyPhysical( vn: VN)\r\n{\r\n\t// get the DOM node before we call unmount, because unmount will clear it.\r\n\tlet ownDN = vn.ownDN;\r\n\r\n\tif (vn.unmount)\r\n\t{\r\n//////////////////////\r\n///////////////////////////////////////////////////////////////////\r\n////////////\r\n\t\tvn.unmount();\r\n\t}\r\n\r\n\t// If the virtual node has its own DOM node, we remove it from the DOM tree. In this case,\r\n\t// we don't need to recurse into sub-nodes, because they are removed with the parent.\r\n\tif (ownDN)\r\n\t\t(ownDN as any as ChildNode).remove();\r\n\telse if (vn.subNodes)\r\n\t{\r\n\t\t// loop over sub-nodes from last to first because this way the DOM element removal is\r\n\t\t// easier.\r\n\t\tfor( let i = vn.subNodes.length - 1; i >=0; i--)\r\n\t\t\tdestroyPhysical( vn.subNodes[i]);\r\n\t}\r\n\r\n\tvn.term();\r\n\r\n\tvn.anchorDN = undefined;\r\n}\r\n\r\n\r\n\r\n// Recursively renders this node and updates its sub-nodes if necessary. This method is\r\n// invoked when a node is being updated either as a result of updateMe invocation or because\r\n// the parent node was updated. If an exception is thrown during the execution of this method\r\n// (which can be only from components' shouldUpdate or render methods), the component is asked\r\n// to handle the error. If the component handles the error, the component is asked to render\r\n// again; otherwise, the exception is re-thrown. Thus, the exception is propagated up until it\r\n// is handled by a node that handles it or up to the root node.\r\nfunction updateVirtual( disp: VNDisp): void\r\n{\r\n\t// let vn = disp.action === VNDispAction.Insert ? disp.newVN : disp.oldVN;\r\n\tlet vn = disp.oldVN;\r\n\r\n\t// keep track of the node that is being currently processed.\r\n\tlet currentVN = vn;\r\n\ts_currentVN = currentVN;\r\n\r\n\ttry\r\n\t{\r\n\t\tupdateSubNodesVirtual( disp);\r\n\t}\r\n\tcatch( err)\r\n\t{\r\n\t\tif (vn.supportsErrorHandling && vn.supportsErrorHandling())\r\n\t\t{\r\n///////////////////////\r\n////////////////////////////////////////////////////////////////////////\r\n/////////////\r\n\r\n\t\t\t// let the node handle its own error and re-render\r\n\t\t\tvn.handleError( err, getVNPath( s_currentVN));\r\n\t\t\tupdateSubNodesVirtual( disp);\r\n\t\t}\r\n\t\telse\r\n\t\t\tthrow err;\r\n\t}\r\n\r\n\t// indicate that the node was updated in this cycle - this will prevent it from \r\n\t// rendering again in this cycle.\r\n\tvn.lastUpdateTick = s_currentTick;\r\n\r\n\t// restore pointer to the currently being processed node after processing its sub-nodes\r\n\ts_currentVN = currentVN;\r\n}\r\n\r\n\r\n\r\n// Performs rendering phase of the update on the sub-nodes of the node, which is passed as\r\n// the oldVN member of the VNDisp structure.\r\nfunction updateSubNodesVirtual( disp: VNDisp): void\r\n{\r\n\t// render the new content and build array of dispositions objects for the sub-nodes.\r\n\tdisp.buildSubNodeDispositions();\r\n\r\n\t// for nodes to be removed, call willUnmount\r\n\tif (disp.subNodesToRemove)\r\n\t{\r\n\t\tfor( let svn of disp.subNodesToRemove)\r\n\t\t\tpreDestroy( svn);\r\n\t}\r\n\r\n\t// perform rendering for sub-nodes that should be inserted, replaced or updated\r\n\tif (disp.subNodeDisps)\r\n\t{\r\n\t\tlet oldVN: VN, newVN: VN;\r\n\t\tlet parentVN = disp.oldVN;\r\n\t\tfor( let subNodeDisp of disp.subNodeDisps)\r\n\t\t{\r\n\t\t\toldVN = subNodeDisp.oldVN;\r\n\t\t\tnewVN = subNodeDisp.newVN;\r\n\t\t\tif (subNodeDisp.action === VNDispAction.Update)\r\n\t\t\t{\r\n\t\t\t\tif (oldVN !== newVN && oldVN.prepareUpdate)\r\n\t\t\t\t{\r\n/////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n///////////////\r\n\t\t\t\t\tsubNodeDisp.updateDisp = oldVN.prepareUpdate( newVN);\r\n\t\t\t\t\tif (subNodeDisp.updateDisp.shouldRender)\r\n\t\t\t\t\t\tupdateVirtual( subNodeDisp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (subNodeDisp.action === VNDispAction.Insert)\r\n\t\t\t\tcreateVirtual( newVN, parentVN);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Recursively performs DOM updates corresponding to this VN and its sub-nodes.\r\nfunction updatePhysical( disp: VNDisp): void\r\n{\r\n\t// remove from DOM the old nodes designated to be removed (that is, those for which there\r\n\t// was no counterpart new node that would either update or replace it). We need to remove\r\n\t// old nodes first before we start inserting new - one reason is to properly maintain\r\n\t// references.\r\n\tif (disp.subNodesToRemove)\r\n\t{\r\n\t\tfor( let svn of disp.subNodesToRemove)\r\n\t\t\tdestroyPhysical( svn);\r\n\t}\r\n\r\n\t// get the node whose children are being updated. This is always the oldVN member of\r\n\t// the disp structure.\r\n\tlet vn = disp.oldVN;\r\n\r\n\t// it might happen that the node being updated was already deleted by its parent. Check\r\n\t// for this situation and exit if this is the case\r\n\tif (!vn.anchorDN)\r\n\t\treturn;\r\n\r\n\t// determine the anchor node to use when inserting new or moving existing sub-nodes. If\r\n\t// our node has its own DN, it will be the anchor for the sub-nodes; otherwise, our node's\r\n\t// anchor will be the anchor for the sub-nodes too.\r\n\tlet ownDN = vn.ownDN;\r\n\tlet anchorDN = ownDN != null ? ownDN : vn.anchorDN;\r\n\r\n\t// if this virtual node doesn't define its own DOM node (true for components), we will\r\n\t// need to find a DOM node before which to start inserting new nodes. Null means\r\n\t// append to the end of the anchor node's children.\r\n\tlet beforeDN = ownDN != null ? null : getNextDNUnderSameAnchorDN( vn, anchorDN);\r\n\r\n\t// re-create our current list of sub-nodes - we will populate it while updating them\r\n\tvn.subNodes = disp.subNodeDisps ? new Array<VN>(disp.subNodeDisps.length) : undefined;\r\n\tvn.keyedSubNodes = vn.subNodes !== undefined && vn.subNodes.length > 1 ? new Map<any,VN>() : undefined;\r\n\r\n\t// perform updates and inserts by either groups or individual nodes.\r\n\tif (disp.subNodeGroups)\r\n\t{\r\n\t\tupdatePhysicalByGroups( vn, disp.subNodeDisps, disp.subNodeGroups, anchorDN, beforeDN);\r\n\t\tarrangeGroups( vn, disp.subNodeDisps, disp.subNodeGroups, anchorDN, beforeDN);\r\n\t}\r\n\telse if (disp.subNodeDisps)\r\n\t{\r\n\t\tupdatePhysicalByNodes( vn, disp.subNodeDisps, anchorDN, beforeDN);\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Performs updates and inserts by individual nodes.\r\nfunction updatePhysicalByNodes( parentVN: VN, disps: VNDisp[], anchorDN: DN, beforeDN: DN): void\r\n{\r\n\t// perform DOM operations according to sub-node disposition. We need to decide for each\r\n\t// node what node to use to insert or move it before. We go from the end of the list of\r\n\t// new nodes and on each iteration we decide the value of the \"beforeDN\".\r\n\tlet nextVN: VN, svn: VN, disp: VNDisp, newVN: VN, oldVN: VN, firstDN: DN;\r\n\tfor( let i = disps.length - 1; i >= 0; i--)\r\n\t{\r\n\t\tdisp = disps[i];\r\n\t\tnewVN = disp.newVN;\r\n\t\toldVN = disp.oldVN;\r\n\r\n\t\t// for the Update operation, the new node becomes a sub-node; for the Insert operation\r\n\t\t// the new node become a sub-node.\r\n\t\tsvn = disp.action === VNDispAction.Update ? oldVN : newVN;\r\n\t\tparentVN.subNodes[i] = svn;\r\n\r\n\t\tif (disp.action === VNDispAction.Update)\r\n\t\t{\r\n\t\t\tif (oldVN !== newVN)\r\n\t\t\t{\r\n\t\t\t\tif (disp.updateDisp.shouldCommit)\r\n\t\t\t\t{\r\n/////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n///////////////\r\n\r\n\t\t\t\t\toldVN.commitUpdate( newVN);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update the sub-nodes if necessary\r\n\t\t\t\tif (disp.updateDisp.shouldRender)\r\n\t\t\t\t\tupdatePhysical( disp);\r\n\t\t\t}\r\n\r\n\t\t\t// determine whether all the nodes under this VN should be moved.\r\n\t\t\tlet subNodeDNs = getImmediateDNs( oldVN);\r\n\t\t\tif (subNodeDNs.length > 0)\r\n\t\t\t{\r\n\t\t\t\t// check whether the last of the DOM nodes already resides right before the needed node\r\n\t\t\t\tif (subNodeDNs[subNodeDNs.length - 1].nextSibling !== beforeDN)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor( let subNodeDN of subNodeDNs)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tanchorDN.insertBefore( subNodeDN, beforeDN);\r\n\r\n///////////////////////\r\n//////////////////////////////////////////////////////////////////////\r\n////////////////\r\n\t\t\t\t\t}\r\n\r\n//////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n///////////////\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the first of DOM nodes become the next beforeDN\r\n\t\t\t\tbeforeDN = subNodeDNs[0];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (disp.action === VNDispAction.Insert)\r\n\t\t{\r\n\t\t\t// since we already destroyed old nodes designated to be replaced, the code is\r\n\t\t\t// identical for Replace and Insert actions\r\n\t\t\tcreatePhysical( newVN, anchorDN, beforeDN);\r\n\r\n\t\t\t// if the new node defines a DOM node, it becomes the DOM node before which\r\n\t\t\t// next components should be inserted/moved\r\n\t\t\tfirstDN = getFirstDN( newVN);\r\n\t\t\tif (firstDN != null)\r\n\t\t\t\tbeforeDN = firstDN;\r\n\t\t}\r\n\r\n\t\tif (parentVN.keyedSubNodes !== undefined && svn.key !== undefined)\r\n\t\t\tparentVN.keyedSubNodes.set( svn.key, svn);\r\n\r\n\t\tsvn.next = svn.prev = undefined;\r\n\t\tif (nextVN)\r\n\t\t{\r\n\t\t\tnextVN.prev = svn;\r\n\t\t\tsvn.next = nextVN;\r\n\t\t}\r\n\r\n\t\tnextVN = svn;\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Performs updates and inserts by groups. We go from the end of the list of update groups\r\n// and on each iteration we decide the value of the \"beforeDN\".\r\nfunction updatePhysicalByGroups( parentVN: VN, disps: VNDisp[], groups: VNDispGroup[], anchorDN: DN, beforeDN: DN): void\r\n{\r\n\tlet currSubNodeIndex = disps.length - 1;\r\n\tlet nextVN: VN, svn: VN, disp: VNDisp, newVN: VN, oldVN: VN, firstDN: DN;\r\n\tfor( let i = groups.length - 1; i >= 0; i--)\r\n\t{\r\n\t\tlet group = groups[i];\r\n\r\n\t\t// first update every sub-node in the group and its sub-sub-nodes\r\n\t\tfor( let j = group.last; j >= group.first; j--)\r\n\t\t{\r\n\t\t\tdisp = disps[j];\r\n\t\t\tnewVN = disp.newVN;\r\n\t\t\toldVN = disp.oldVN;\r\n\r\n\t\t\t// for the Update operation, the new node becomes a sub-node; for the Insert operation\r\n\t\t\t// the new node become a sub-node.\r\n\t\t\tsvn = group.action === VNDispAction.Update ? oldVN : newVN;\r\n\t\t\tparentVN.subNodes[currSubNodeIndex--] = svn;\r\n\r\n\t\t\tif (group.action === VNDispAction.Update)\r\n\t\t\t{\r\n\t\t\t\tif (oldVN !== newVN)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (disp.updateDisp.shouldCommit)\r\n\t\t\t\t\t{\r\n//////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n////////////////\r\n\r\n\t\t\t\t\t\toldVN.commitUpdate( newVN);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// update the sub-nodes if necessary\r\n\t\t\t\t\tif (disp.updateDisp.shouldRender)\r\n\t\t\t\t\t\tupdatePhysical( disp);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfirstDN = getFirstDN( oldVN);\r\n\t\t\t\tif (firstDN != null)\r\n\t\t\t\t\tbeforeDN = firstDN;\r\n\t\t\t}\r\n\t\t\telse if (group.action === VNDispAction.Insert)\r\n\t\t\t{\r\n\t\t\t\tcreatePhysical( newVN, anchorDN, beforeDN);\r\n\r\n\t\t\t\t// if the new node defines a DOM node, it becomes the DOM node before which\r\n\t\t\t\t// next components should be inserted/moved\r\n\t\t\t\tfirstDN = getFirstDN( newVN);\r\n\t\t\t\tif (firstDN != null)\r\n\t\t\t\t\tbeforeDN = firstDN;\r\n\t\t\t}\r\n\r\n\t\t\tif (parentVN.keyedSubNodes !== undefined && svn.key !== undefined)\r\n\t\t\t\tparentVN.keyedSubNodes.set( svn.key, svn);\r\n\r\n\t\t\tsvn.next = svn.prev = undefined;\r\n\t\t\tif (nextVN)\r\n\t\t\t{\r\n\t\t\t\tnextVN.prev = svn;\r\n\t\t\t\tsvn.next = nextVN;\r\n\t\t\t}\r\n\r\n\t\t\tnextVN = svn;\r\n\t\t}\r\n\r\n\t\t// now that all nodes in the group have been updated or inserted, we can determine\r\n\t\t// first and last DNs for the group\r\n\t\tgroup.determineDNs();\r\n\r\n\t\t// if the group has at least one DN, its first DN becomes the node before which the next\r\n\t\t// group of new nodes (if any) should be inserted.\r\n\t\tif (group.firstDN)\r\n\t\t\tbeforeDN = group.firstDN;\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Arrange the groups in order as in the new sub-node list, moving them if necessary.\r\nfunction arrangeGroups( parentVN: VN, disps: VNDisp[], groups: VNDispGroup[], anchorDN: DN, beforeDN: DN): void\r\n{\r\n\t// We go from the last group to the second group in the list because as soon as we moved all\r\n\t// groups except the first one into their right places, the first group will be automatically\r\n\t// in the right place. We always have two groups (i and i-1), which allows us to understand\r\n\t// whether we need to swap them. If we do we move the shorter group.\r\n\tfor( let i = groups.length - 1; i > 0; i--)\r\n\t{\r\n\t\tlet group = groups[i];\r\n\t\tlet prevGroup = groups[i-1];\r\n\r\n\t\t// determine whether the group should move. We take the last node from the group\r\n\t\t// and compare its DN's next sibling to the current \"beforeDN\".\r\n\t\tif (group.lastDN != null)\r\n\t\t{\r\n\t\t\tif (group.lastDN.nextSibling !== beforeDN)\r\n\t\t\t{\r\n\t\t\t\t// if the current group now resides before the previous group, then that means\r\n\t\t\t\t// that we are swapping two groups. In this case we want to move the shorter one.\r\n\t\t\t\tif (group.lastDN.nextSibling === prevGroup.firstDN && group.count > prevGroup.count)\r\n\t\t\t\t\tmoveGroup( parentVN, disps, prevGroup, anchorDN, group.firstDN);\r\n\t\t\t\telse\r\n\t\t\t\t\tmoveGroup( parentVN, disps, group, anchorDN, beforeDN);\r\n\t\t\t}\r\n\r\n\t\t\t// the group's first DN becomes the new beforeDN. Note that firstDN cannot be null\r\n\t\t\t// because lastDN is not null\r\n\t\t\tbeforeDN = group.firstDN;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Moves all the nodes in the given group before the given DOM node.\r\nfunction moveGroup( parentVN: VN, disps: VNDisp[], group: VNDispGroup, anchorDN: DN, beforeDN: DN): void\r\n{\r\n\tfor( let j = group.first; j <= group.last; j++)\r\n\t{\r\n\t\tlet subNodeVN = group.action === VNDispAction.Update ? disps[j].oldVN : disps[j].newVN;\r\n\t\tlet subNodeDNs = getImmediateDNs( subNodeVN);\r\n\t\tfor( let subNodeDN of subNodeDNs)\r\n\t\t{\r\n\t\t\tanchorDN.insertBefore( subNodeDN, beforeDN);\r\n\r\n////////////////////\r\n///////////////////////////////////////////////////////////////////\r\n/////////////\r\n\t\t}\r\n\r\n///////////////////\r\n////////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {VNBase} from \"./VNBase\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The class CompBaseVN is a base class for InstanceVN and ClassVN. It provides common functionality\r\n// in terms of update requests and lifecycle management.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport abstract class ClassCompVN<TComp extends mim.IComponent> extends VNBase implements mim.IClassCompVN\r\n{\r\n\t// Component instance.\r\n\tpublic comp: TComp;\r\n\r\n\r\n\r\n//////////////////\r\n//////////////////////////////////////////////////////////////////////////\r\n///////////\r\n\r\n\r\n\r\n\t/**\r\n\t * Retrieves update strategy object that determines different aspects of node behavior\r\n\t * during updates.\r\n\t */\r\n\tpublic get updateStrategy(): mim.UpdateStrategy\r\n\t{\r\n\t\treturn this.comp.getUpdateStrategy ? this.comp.getUpdateStrategy() : undefined;\r\n\t}\r\n\r\n\r\n\r\n\t// Generates list of sub-nodes according to the current state\r\n\tpublic render(): any\r\n\t{\r\n///////////////\r\n///////////////////////////////\r\n////\r\n//////////////////////////////////////////////////////////////////\r\n////////////////\r\n////\r\n////////////\r\n\r\n//////////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n///////////////////\r\n//////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\treturn this.comp.render();\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the node supports handling of errors; that is, exception thrown during\r\n\t// rendering of the node itself and/or its sub-nodes.\r\n\tpublic supportsErrorHandling(): boolean\r\n\t{\r\n\t\treturn this.comp.handleError !== undefined;\r\n\t}\r\n\r\n\r\n\r\n\t// This method is called after an exception was thrown during rendering of the node itself\r\n\t// and/or its sub-nodes.\r\n\tpublic handleError( err: any, path: string[]): void\r\n\t{\r\n\t\tthis.comp.handleError( err, path);\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\n\r\n/////////////////\r\n//////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Type of properties that can be specified for an element.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport const enum PropType\r\n{\r\n\t// Regular attributes set using Element.setAttribute();\r\n\tUnknown = 0,\r\n\r\n\t// Regular attributes set using Element.setAttribute();\r\n\tAttr = 1,\r\n\r\n\t// Event listeners set using Element.addEventListener\r\n\tEvent = 2,\r\n\r\n\t// Custom attributes for which handler factories are registered\r\n\tCustomAttr = 3,\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Base interface describing information kept about property that can be specified for an element.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface PropInfoBase\r\n{\r\n\t// Type of the property.\r\n\ttype: PropType;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Information about attributes that contains functions for setting, diffing, updating and\r\n// removing attribute(s) corresponding to the property.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface AttrPropInfo extends PropInfoBase\r\n{\r\n\t// Function that sets the value of the attribute. If this function is not defined, then the DOM\r\n\t// elm.setAttribute is called with propName as attribute name and propVal converted to string.\r\n\tset?: (elm: Element, attrName: string, propVal: any) => void;\r\n\r\n\t// Function that compares the old and the new value of the attribute and returns an object\r\n\t// that will be passed to the updateFunc function. If undefined is returned, the value of the\r\n\t// attribute will not change (that means the old and the new values are equal). If this\r\n\t// function is not defined, property values are converted to string and compared as strings.\r\n\t// If these strings are different, the string corresponding to the  new value is returned.\r\n\tdiff?: (attrName: string, oldPropVal: any, newPropVal: any) => any;\r\n\r\n\t// Function that updates the value of the attribute based on the object that was returned\r\n\t// from the diff function. If this function is not defined, then the set function is used. If\r\n\t// the set function is not defined either, the DOM elm.setAttribute is called with propName as\r\n\t// attribute name and updateVal converted to string.\r\n\tupdate?: (elm: Element, attrName: string, updateVal: any) => void;\r\n\r\n\t// Function that removes the attribute. If this function is not defined, then the DOM\r\n\t// elm.removeAttribute is called with propName as attribute name.\r\n\tremove?: (elm: Element, attrName: string) => void;\r\n\r\n\t// The actual name of the attribute. This is sometimes needed if the attribute name cannot be\r\n\t// used as property name - for example, if attribute name contains characters not allowed in\r\n\t// TypeScript identifier (e.g. dash).\r\n\tattrName?: string;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Information about events.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface EventPropInfo extends PropInfoBase\r\n{\r\n\t// Flag indicating whether the event bubbles. If the event doesn't bubble, the event handler\r\n\t// must be set on the element itself; otherwise, the event handler can be set on the root\r\n\t// anchor element, which allows having a single event handler registered for many elements,\r\n\t// which is more performant.\r\n\tisBubbling?: boolean;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Information about custom attributes.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface CustomAttrPropInfo extends PropInfoBase\r\n{\r\n\t// Class object that creates custom attribute handlers.\r\n\thandlerClass: mim.ICustomAttributeHandlerClass<any>;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Type combining information about regular attributes or events or custom attributes.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport type PropInfo = AttrPropInfo | EventPropInfo | CustomAttrPropInfo;\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Exported class that provides static methods for setting, updating and removing Element\r\n// attributes corresponding to property names.\r\n//\r\n// Element attributes are determined using properties passed to the ElmVN methods. Some\r\n// properties allow using non-trivial types, e.g. arrays or objects, and thus cannot be simply\r\n// handled using the Element.setAttribute method.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class ElmAttr\r\n{\r\n\t// Object that maps property names to PropInfo-derived objects. Information about custom\r\n\t// attributes is added to this object when the registerProperty method is called.\r\n\tprivate static propInfos: {[P:string]: PropInfo} =\r\n\t{\r\n\t\t// attributes - only those attributes are listed that have non-trivial treatment\r\n\t\t\"style\": { type: PropType.Attr, set: setStyleProp, diff: diffStyleProp, update: updateStyleProp },\r\n\t\t\"value\": { type: PropType.Attr, set: setValueProp, diff: diffValueProp, remove: removeValueProp },\r\n\t\t\"defaultValue\": { type: PropType.Attr, set: setValueProp, diff: diffDefaultValueProp, remove: removeDefaultValueProp },\r\n\t\t\"checked\": { type: PropType.Attr, set: setCheckedProp, diff: diffCheckedProp, remove: removeCheckedProp },\r\n\t\t\"defaultChecked\": { type: PropType.Attr, set: setCheckedProp, diff: diffDefaultValueProp, remove: removeDefaultValueProp },\r\n\r\n\t\t// event listeners - only those event are listed that are non-bubbling\r\n\t\t\"mouseenter\": { type: PropType.Event, isBubbling: false },\r\n\t\t\"mouseleave\": { type: PropType.Event, isBubbling: false },\r\n\t};\r\n\r\n\r\n\r\n\t// Registers information about the given property.\r\n\tpublic static registerProperty( propName: string, info: AttrPropInfo | EventPropInfo | CustomAttrPropInfo): void\r\n\t{\r\n\t\tElmAttr.propInfos[propName] = info;\r\n\t}\r\n\r\n\r\n\r\n\t// Registers information about the given property.\r\n\tpublic static getPropertyInfo( propName: string): PropInfo | undefined\r\n\t{\r\n\t\treturn ElmAttr.propInfos[propName];\r\n\t}\r\n\r\n\r\n\r\n\t// Using the given property name and its value set the appropriate attribute(s) on the\r\n\t// element. This method handles special cases of properties with non-trivial values.\r\n\tpublic static setAttr( elm: Element, propName: string, info: AttrPropInfo | null, propVal: any): void\r\n\t{\r\n\t\t// get property info object\r\n\t\tif (info === undefined)\r\n\t\t\telm.setAttribute( propName, typeof propVal === \"string\" ? propVal : propVal.toString());\r\n\t\telse\r\n\t\t{\r\n\t\t\t// get actual attribute name to use\r\n\t\t\tlet attrName: string = info.attrName;\r\n\t\t\tif (attrName === undefined)\r\n\t\t\t\tattrName = propName;\r\n\r\n\t\t\tif (info.set !== undefined)\r\n\t\t\t\tinfo.set( elm, attrName, propVal);\r\n\t\t\telse\r\n\t\t\t\telm.setAttribute( attrName, typeof propVal === \"string\" ? propVal : propVal.toString());\r\n\t\t}\r\n\r\n///////////////////\r\n///////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the old and the new values of the property are different and sets the\r\n\t// updated value to the element's attribute. Returns true if update has been performed and\r\n\t// false if no change in property value has been detected.\r\n\tpublic static updateAttr( elm: Element, propName: string, info: AttrPropInfo | null, oldPropVal: any, newPropVal: any): boolean\r\n\t{\r\n\t\t// get property info object\r\n\t\tif (info === undefined)\r\n\t\t{\r\n\t\t\t// if this is not a special case (property is not in our list) just compare them and\r\n\t\t\t// if they are different set the attribute to the new value.\r\n\t\t\tif (oldPropVal === newPropVal)\r\n\t\t\t\treturn false;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\telm.setAttribute( propName, typeof newPropVal === \"string\" ? newPropVal : newPropVal.toString());\r\n\r\n/////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n//////////////\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// compare old and new value using the update function if defined; if not, just compare\r\n\t\t// the two values and if they are different use the new one as a value to update with.\r\n\t\t// Note that the neither old nor new values can be undefined or null.\r\n\t\tlet updateVal: any;\r\n\t\tif (info.diff !== undefined)\r\n\t\t{\r\n\t\t\tupdateVal = info.diff( propName, oldPropVal, newPropVal);\r\n\r\n\t\t\t// if updateValue is undefined then no change has been detected.\r\n\t\t\tif (updateVal === undefined)\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (oldPropVal !== newPropVal)\r\n\t\t\tupdateVal = newPropVal;\r\n\r\n\t\t// get actual attribute name to use\r\n\t\tlet attrName: string = info.attrName;\r\n\t\tif (attrName === undefined)\r\n\t\t\tattrName = propName;\r\n\r\n\t\t// if update method is defined use it; otherwise, remove the old value and set the new one\r\n\t\tif (info.update !== undefined)\r\n\t\t\tinfo.update( elm, attrName, updateVal);\r\n\t\telse\r\n\t\t{\r\n\t\t\t// if remove method is defined, use it. Note that if remove method is not defined\r\n\t\t\t// we don't use elm.removeAttribute to save time (as the following info.set or\r\n\t\t\t// elm.setAttribute will override it anyway.\r\n\t\t\tif (info.remove !== undefined)\r\n\t\t\t\tinfo.remove( elm, attrName);\r\n\r\n\t\t\tif (info.set !== undefined)\r\n\t\t\t\tinfo.set( elm, attrName, updateVal);\r\n\t\t\telse\r\n\t\t\t\telm.setAttribute( attrName, typeof updateVal === \"string\" ? updateVal : updateVal.toString());\r\n\t\t}\r\n\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\t// indicate that there was change in attribute value.\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\r\n\t// Removes the attribute(s) corresponding to the given property.\r\n\tpublic static removeAttr( elm: Element, propName: string, info: AttrPropInfo | null): void\r\n\t{\r\n\t\t// get property info object\r\n\t\tif (info === undefined)\r\n\t\t\telm.removeAttribute( propName);\r\n\t\telse\r\n\t\t{\r\n\t\t\t// get actual attribute name to use\r\n\t\t\tlet attrName: string = info.attrName;\r\n\t\t\tif (attrName === undefined)\r\n\t\t\t\tattrName = propName;\r\n\r\n\t\t\tif (info.remove !== undefined)\r\n\t\t\t{\r\n\t\t\t\tinfo.remove( elm, attrName);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\telm.removeAttribute( attrName);\r\n\t\t}\r\n\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n}\r\n\r\n\r\n\r\n//// Register events with special names\r\n//ElmAttr.registerProp( \"smartcardInsert\",\r\n//\t{ mustRemove: mustRemoveListeners, set: setListenerProp, remove: removeListenerProp, attrName: \"smartcard-insert\" });\r\n//ElmAttr.registerProp( \"smartcardInsertCapture\",\r\n//\t{ mustRemove: mustRemoveListeners, set: setListenerCaptureProp, remove: removeListenerCaptureProp, attrName: \"smartcard-insert\" });\r\n//ElmAttr.registerProp( \"smartcardRemove\",\r\n//\t{ mustRemove: mustRemoveListeners, set: setListenerProp, remove: removeListenerProp, attrName: \"smartcard-insert\" });\r\n//ElmAttr.registerProp( \"smartcardRemoveCapture\",\r\n//\t{ mustRemove: mustRemoveListeners, set: setListenerCaptureProp, remove: removeListenerCaptureProp, attrName: \"smartcard-remove\" });\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Handling of style property. Style property can be specified either as a string or as the\r\n// CSSStyleDeclaration object. If the old and new style property values are of different types\r\n// the diff function returns the new style value. If both are of the string type, then the new\r\n// string value is returned. If both are of the CSSStyleDeclaration type, then an object is\r\n// returned whose keys correspond to style items that should be changed. For updated items, the\r\n// key value is from the new style value; for removed items, the key value is undefined.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nfunction setStyleProp( elm: Element, attrName: string, propVal: any): void\r\n{\r\n\tif (propVal === undefined || propVal === null)\r\n\t\telm.removeAttribute( \"style\");\r\n\telse\r\n\t{\r\n\t\tconst elmStyle: CSSStyleDeclaration = (elm as HTMLElement).style;\r\n\t\tfor( let key in propVal as mim.StylePropType)\r\n\t\t{\r\n\t\t\tconst keyVal: any = propVal[key];\r\n\t\t\tif (elmStyle[key] !== keyVal)\r\n\t\t\t\telmStyle[key] = keyVal;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\nfunction diffStyleProp( attrName: string, oldPropVal: any, newPropVal: any): any\r\n{\r\n\tif (typeof oldPropVal !== typeof newPropVal)\r\n\t\treturn newPropVal;\r\n\telse\r\n\t{\r\n\t\tconst oldStyle = oldPropVal as mim.StylePropType;\r\n\t\tconst newStyle = newPropVal as mim.StylePropType;\r\n\r\n\t\tconst updateVal: mim.StylePropType = {};\r\n\t\tlet changesExist: boolean = false;\r\n\r\n\t\t// loop over keys in the old style object and find those that are not in the new one. These\r\n\t\t// will be removed.\r\n\t\tfor( let key in oldStyle)\r\n\t\t{\r\n\t\t\tconst oldVal: any = oldStyle[key];\r\n\t\t\tconst newVal: any = newStyle[key];\r\n\t\t\tif (newVal === undefined)\r\n\t\t\t{\r\n\t\t\t\tchangesExist = true;\r\n\t\t\t\tupdateVal[key] = undefined;\r\n\t\t\t}\r\n\t\t\telse if (newVal !== oldVal)\r\n\t\t\t{\r\n\t\t\t\tchangesExist = true;\r\n\t\t\t\tupdateVal[key] = newVal;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// loop over keys in the new style object and find those that are not in the old one. These\r\n\t\t// will be added.\r\n\t\tfor( let key in newStyle)\r\n\t\t{\r\n\t\t\tconst oldVal: any = oldStyle[key];\r\n\t\t\tif (oldVal === undefined)\r\n\t\t\t{\r\n\t\t\t\tchangesExist = true;\r\n\t\t\t\tupdateVal[key] = newStyle[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn changesExist ? updateVal : undefined;\r\n\t}\r\n}\r\n\r\n\r\n\r\nfunction updateStyleProp( elm: Element, attrName: string, updateVal: any): void\r\n{\r\n\tconst elmStyle: CSSStyleDeclaration = (elm as HTMLElement).style;\r\n\tfor( let key in updateVal as Object)\r\n\t{\r\n\t\tconst keyVal: any = updateVal[key];\r\n\t\tif (keyVal === undefined)\r\n\t\t\telmStyle[key] = null;\r\n\t\t\t//elmStyle[key] = \"initial\";\r\n\t\telse\r\n\t\t\telmStyle[key] = keyVal;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n//// Determines whether the first style is a complete subset of the second one; that is keys\r\n//// in the first style are all found and have the same values in the second style.\r\n//function isStyle1SubsetOfStyle2( style1: Object, style2: Object): boolean\r\n//{\r\n//\tfor( let key1 in style1)\r\n//\t{\r\n//\t\tif (style1[key1] !== style2[key1])\r\n//\t\t\treturn false;\r\n//\t}\r\n\r\n//\treturn true;\r\n//}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Handling of value property. Instead of setting value property as an attribute we set the value\r\n// field on the element. The set and update methods work the same way. We define the remove method\r\n// by setting the elm.value field to null.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nfunction setValueProp( elm: Element, attrName: string, propVal: any): void\r\n{\r\n\t// we need to cast elm to any, because generic Element doesn't have value property.\r\n\t(elm as any).value = propVal;\r\n}\r\n\r\n\r\n\r\n\r\nfunction diffValueProp( attrName: string, oldPropValVal: any, newPropVal: any): boolean\r\n{\r\n\t// by always returning the new property value we cause the value to always be updated to\r\n\t// that of the new property. We want always to set this value to the element because the\r\n\t// element's value may have chnged (by the user or programmatically).\r\n\treturn newPropVal;\r\n}\r\n\r\n\r\n\r\n\r\nfunction removeValueProp( elm: Element, attrName: string): void\r\n{\r\n\t// we need to cast elm to any, because generic Element doesn't have value property.\r\n\t(elm as any).value = null;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Handling of defaultValue property. The defaultValue property works as a value property when the\r\n// element is first mounted and is ignored upon updates and removals. This allows using\r\n// defaultValue to initialize the control value once.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nfunction diffDefaultValueProp( attrName: string, oldPropValVal: any, newPropVal: any): boolean\r\n{\r\n\t// by returning undefined we indicate that no changes were made to the property and thus the\r\n\t// update will not be called\r\n\treturn undefined;\r\n}\r\n\r\n\r\n\r\n\r\nfunction removeDefaultValueProp( elm: Element, attrName: string): void\r\n{\r\n\t// do nothing\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Handling of checked property. Instead of setting checked property as an attribute we set the\r\n// checked field on the element. The set and update methods work the same way. We define the remove\r\n// method by setting the elm.checked field to null.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nfunction setCheckedProp( elm: Element, attrName: string, propVal: any): void\r\n{\r\n\t// we need to cast elm to any, because generic Element doesn't have value property.\r\n\t(elm as any).checked = propVal;\r\n}\r\n\r\n\r\n\r\n\r\nfunction diffCheckedProp( attrName: string, oldPropValVal: any, newPropVal: any): boolean\r\n{\r\n\t// by always returning the new property value we cause the value to always be updated to\r\n\t// that of the new property.\r\n\treturn newPropVal;\r\n}\r\n\r\n\r\n\r\n\r\nfunction removeCheckedProp( elm: Element, attrName: string): void\r\n{\r\n\t// we need to cast elm to any, because generic Element doesn't have value property.\r\n\t(elm as any).checked = false;\r\n}\r\n\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\n\r\n\r\n\r\nexport function deepCompare( o1: any, o2: any): boolean\r\n{\r\n\tif (o1 === o2)\r\n\t\treturn true;\r\n\telse if (o1 == null && o2 == null)\r\n\t\treturn true;\r\n\telse if (o1 == null || o2 == null)\r\n\t\treturn false;\r\n\telse if (typeof o1 !== typeof o2)\r\n\t\treturn false;\r\n\telse if (typeof o1 === \"object\")\r\n\t{\r\n\t\tfor( let p in o1)\r\n\t\t{\r\n\t\t\tif (!deepCompare( o1[p], o2[p]))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor( let p in o2)\r\n\t\t{\r\n\t\t\tif (!(p in o1))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\telse if (Array.isArray(o1) !== Array.isArray(o2))\r\n\t\treturn false;\r\n\telse if (Array.isArray(o1))\r\n\t{\r\n\t\tif (o1.length !== o2.length)\r\n\t\t\treturn false;\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor( let i = 0, len = o1.length; i < len; i++)\r\n\t\t\t{\r\n\t\t\t\tif (!deepCompare( o1[i], o2[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// we are here if these are strings, numbers, booleans or functions and they are different\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nexport function hashObject( o: any): number\r\n{\r\n\tif (o === undefined)\r\n\t\treturn 0;\r\n\telse if (o === null)\r\n\t\treturn 1;\r\n\telse if (isNaN(0))\r\n\t\treturn 2;\r\n\telse if (o === true)\r\n\t\treturn 3;\r\n\telse if (o === false)\r\n\t\treturn 4;\r\n\r\n\tlet h = 10;\r\n\r\n\tif (typeof o === \"number\")\r\n\t\treturn 10 + o;\r\n\telse if (typeof o === \"string\")\r\n\t\treturn hashString( o);\r\n\telse if (typeof o === \"function\")\r\n\t\treturn hashString( o.name);\r\n\telse if (Array.isArray(o))\r\n\t{\r\n\t\tlet len = o.length;\r\n\t\tlet h = 10 + len;\r\n\t\tfor( let i = 0; i < len; i++)\r\n\t\t\t h += i + hashObject( o[i]);\r\n\t\treturn h;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlet h = 10;\r\n\t\tfor( let p in o)\r\n\t\t\th += hashString(p) + hashObject(o[p]);\r\n\t\treturn h;\r\n\t}\r\n}\r\n\r\n\r\n\r\nexport function hashString( s: string): number\r\n{\r\n\tif (!s)\r\n\t\treturn 5;\r\n\r\n\tlet len = s.length;\r\n\tlet h = 10 + len;\r\n\tfor( let i = 0; i < len; i++)\r\n\t\th += s.charCodeAt(i);\r\n\treturn h;\r\n}\r\n\r\n\r\n\r\n// Combines arbitrary number of class properties merging later into the earlier ones. This method\r\n// returns a string or undefined - if all classNames were undefined.\r\nexport function mergeClasses( ...classNames: (string | string[])[]): string\r\n{\r\n\tlet resClassName: string;\r\n\r\n\tfor( let className of classNames)\r\n\t{\r\n\t\tif (!className)\r\n\t\t\tcontinue;\r\n\r\n\t\t// parse the class if it is specified as a string\r\n\t\tlet classNameAsString: string = typeof className === \"string\"\r\n\t\t\t\t? className as string\r\n\t\t\t\t: (className as string[]).join( \" \");\r\n\r\n\t\tif (resClassName === undefined)\r\n\t\t\tresClassName = \"\";\r\n\t\telse\r\n\t\t\tresClassName += \" \";\r\n\r\n\t\tresClassName += classNameAsString;\r\n\t}\r\n\r\n\treturn resClassName;\r\n}\r\n\r\n\r\n\r\n// Combines arbitrary number of style objects merging later into the earlier ones. This method\r\n// always returns an object - even if empty\r\nexport function mergeStyles( ...styles: mim.StylePropType[]): mim.StylePropType\r\n{\r\n\t// create an empty object for accumulating style properties\r\n\tlet resStyle: mim.StylePropType = {};\r\n\tmergeStylesTo( resStyle, ...styles);\r\n\treturn resStyle;\r\n}\r\n\r\n\r\n\r\n// Combines arbitrary number of style objects merging later into the first one.\r\nexport function mergeStylesTo( resStyle: mim.StylePropType, ...styles: (mim.StylePropType | string)[] ): void\r\n{\r\n\tfor( let style of styles)\r\n\t{\r\n\t\tif (!style)\r\n\t\t\tcontinue;\r\n\r\n\t\t// parse the style if it is specified as a string\r\n\t\tlet styleObj: mim.StylePropType = typeof style === \"object\"\r\n\t\t\t\t? style as mim.StylePropType\r\n\t\t\t\t: parseStyleString( style as string);\r\n\r\n\t\t// copy all properties defined in teh current style object to our resultant object\t\t\t\r\n\t\tfor( let propName in styleObj)\r\n\t\t\tresStyle[propName] = styleObj[propName];\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Parses the given style string into the Style object.\r\nexport function parseStyleString( s: string): mim.StylePropType\r\n{\r\n\tif (!s)\r\n\t\treturn {};\r\n\r\n\tlet retStyle: mim.StylePropType = {};\r\n\r\n\tlet elms: string[] = s.split(\";\");\r\n\tfor( let elm of elms)\r\n\t{\r\n\t\tlet pair: string[] = elm.split( \":\");\r\n\t\tif (!pair || pair.length === 0 || pair.length > 2)\r\n\t\t\tcontinue;\r\n\r\n\t\tretStyle[dashToCamel( pair[0].trim())] = pair[1].trim();\r\n\t}\r\n\r\n\treturn retStyle;\r\n}\r\n\r\n\r\n\r\n// Converts names with dashes into names in camelCase, where every character after a dash is\r\n// capitalized and dashes are removed.\r\nexport function dashToCamel( dash: string): string\r\n{\r\n\tif (!dash)\r\n\t\treturn dash;\r\n\r\n\tlet camel: string;\r\n\tlet index: number = -1;\r\n\tlet nextIndexToCopyFrom: number = 0;\r\n\twhile( (index = dash.indexOf( \"-\", index + 1)) >= 0)\r\n\t{\r\n\t\tif (camel === undefined)\r\n\t\t\tcamel = \"\";\r\n\r\n\t\tcamel += dash.substr( nextIndexToCopyFrom, index - nextIndexToCopyFrom);\r\n\t\tif (index != dash.length - 1)\r\n\t\t\tcamel += dash[index + 1].toUpperCase();\r\n\r\n\t\tnextIndexToCopyFrom = index + 2;\r\n\t}\r\n\r\n\tif (camel === undefined)\r\n\t\treturn dash;\r\n\telse\r\n\t{\r\n\t\tif (nextIndexToCopyFrom < dash.length)\r\n\t\t\tcamel += dash.substr( nextIndexToCopyFrom);\r\n\r\n\t\treturn camel;\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Combines arbitrary number of Slice objects merging classes, styles, properties and content\r\nexport function mergeSlices( ...slices: mim.Slice[]): mim.Slice\r\n{\r\n\tlet resSlice: mim.Slice = {};\r\n\tmergeSlicesTo( resSlice, ...slices);\r\n\treturn resSlice;\r\n}\r\n\r\n\r\n\r\n// Combines arbitrary number of Slice objects merging classes, styles, properties and content\r\n// into the given resultant slice.\r\nexport function mergeSlicesTo( resSlice: mim.Slice, ...slices: mim.Slice[]): void\r\n{\r\n\tif (resSlice === undefined || resSlice === null)\r\n\t\treturn;\r\n\r\n\tfor( let slice of slices)\r\n\t{\r\n\t\tif (!slice)\r\n\t\t\tcontinue;\r\n\r\n\t\tif (slice.style)\r\n\t\t{\r\n\t\t\tif (resSlice.style === undefined)\r\n\t\t\t\tresSlice.style = {};\r\n\r\n\t\t\tmergeStylesTo( resSlice.style, slice.style);\r\n\t\t}\r\n\r\n\t\tif (slice.className)\r\n\t\t{\r\n\t\t\tif (resSlice.className === undefined)\r\n\t\t\t\tresSlice.className = \"\";\r\n\r\n\t\t\tresSlice.className = mergeClasses( resSlice.className as string, slice.className);\r\n\t\t}\r\n\r\n\t\tif (slice.props)\r\n\t\t{\r\n\t\t\tif (resSlice.props === undefined)\r\n\t\t\t\tresSlice.props = {};\r\n\r\n\t\t\tfor( let propName in slice.props)\r\n\t\t\t\tresSlice[propName] = slice[propName];\r\n\t\t}\r\n\r\n\t\tif (slice.content)\r\n\t\t{\r\n\t\t\tif (resSlice.content === undefined)\r\n\t\t\t\tresSlice.content = slice.content;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (!Array.isArray( resSlice.content))\r\n\t\t\t\t{\r\n\t\t\t\t\tlet oldContent: any = resSlice.content;\r\n\t\t\t\t\tresSlice.content = [];\r\n\t\t\t\t\tresSlice.content.push( oldContent);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresSlice.content.push( slice.content);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n","// Type definitions for mimbl\r\n\r\nexport * from \"./api/mim\";\r\nexport * from \"./api/HtmlTypes\";\r\nexport * from \"./api/SvgTypes\";\r\nexport * from \"./api/LocalStyles\";\r\n","///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The IEventSlot interface represents an event with custom parameters. Multiple\r\n// listeners can be added/removed to/from an event.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface IEventSlot<TFunc extends Function>\r\n{\r\n\t// Method that raises the event and calls all the listeners (if any). It has the signature\r\n\t// of the template function so only proper-types parameters can be passed to it.\r\n\tfire: TFunc;\r\n\r\n\t// Adds the given function as a listener to the event. Note that this cannot be a lambda\r\n\t// function because there will be no way to remove a lambda function listener later.\r\n\tadd( listener: TFunc): void;\r\n\r\n\t// Removes the given function as a listener to the event.\r\n\tremove( listener: TFunc): void;\r\n\r\n\t// Removes all listeners to the event.\r\n\tclear(): void;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The EventSlot class defines an event with custom parameters as members of classes without the\r\n// need for the classes to derive from EventTarget and use string names for events. Multiple\r\n// listeners can be added/removed to/from an event.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class EventSlot<TFunc extends Function> implements IEventSlot<TFunc>\r\n{\r\n\t// Method that raises the event and calls all the listeners (if any). It has the signature\r\n\t// of the template function so only proper-types parameters can be passed to it.\r\n\tpublic fire: TFunc = this.realFire as any as TFunc;\r\n\r\n\r\n\r\n\t// Adds the given function as a listener to the event. Note that this should not be a lambda\r\n\t// function because there will be no way to remove a lambda function listener later.\r\n\tpublic add( listener: TFunc): void\r\n\t{\r\n\t\tif (this.listeners === null)\r\n\t\t\tthis.listeners = new Set<TFunc>();\r\n\r\n\t\tthis.listeners.add( listener);\r\n\t}\r\n\r\n\r\n\r\n\t// Removes the given function as a listener to the event.\r\n\tpublic remove( listener: TFunc): void\r\n\t{\r\n\t\tif (this.listeners !== null)\r\n\t\t{\r\n\t\t\tthis.listeners.delete( listener);\r\n\t\t\tif (this.listeners.size === 0)\r\n\t\t\t\tthis.listeners = null;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Removes all listener to the event.\r\n\tpublic clear(): void\r\n\t{\r\n\t\tthis.listeners = null;\r\n\t}\r\n\r\n\r\n\r\n\t// Set of listener functions. When there are no listeners, this field is set to null to\r\n\t// preserve space.\r\n\tprivate listeners: Set<TFunc> = null;\r\n\r\n\r\n\r\n\t// This method really calls the listeners in a loop. It deconstucts the \"arguments\" value\r\n\t// in order to pass the proper parameters to the listeners.\r\n\tprivate realFire(): void\r\n\t{\r\n\t\tif (this.listeners !== null)\r\n\t\t{\r\n\t\t\tfor( let listener of this.listeners)\r\n\t\t\t\tlistener( ...arguments);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The EventMultiSlot class allows registering listeners for multiple events. Events are identified\r\n// using the specified template type, which is usually (but not necessarily) a number- or\r\n// string-based enumeration or union type.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class EventMultiSlot<T>\r\n{\r\n\t// Adds a new listener to the given event\r\n\tpublic addListener( event: T, eventFunc: Function): void\r\n\t{\r\n\t\tif (this.slots === undefined)\r\n\t\t\tthis.slots = new Map<T,EventSlot<Function>>();\r\n\r\n\t\tlet slot = this.slots.get( event);\r\n\t\tif (slot === undefined)\r\n\t\t{\r\n\t\t\tslot = new EventSlot<Function>();\r\n\t\t\tthis.slots.set( event, slot);\r\n\t\t}\r\n\r\n\t\tslot.add( eventFunc);\r\n\t}\r\n\r\n\r\n\r\n\t// Removes the given listener from the given event\r\n\tpublic removeListener( event: T, eventFunc: Function): void\r\n\t{\r\n\t\tif (this.slots !== undefined)\r\n\t\t{\r\n\t\t\tlet slot = this.slots.get( event);\r\n\t\t\tif (slot !== undefined)\r\n\t\t\t\tslot.remove( eventFunc);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate slots: Map<T,EventSlot<Function>>;\r\n}\r\n\r\n\r\n\r\n// Interface and class for simple events accepting no parameters.\r\nexport interface ISimpleEventSlot extends IEventSlot<()=>void> {}\r\nexport class SimpleEventSlot extends EventSlot<()=>void> {}\r\n\r\n\r\n","import {DN, VN, VNUpdateDisp, getFirstDN, getLastDN} from \"./VN\"\r\nimport {createVNChainFromContent} from \"./ContentFuncs\"\r\n\r\n\r\n\r\n/**\r\n * The VNAction enumeration specifies possible actions to perform for new nodes during\r\n * reconciliation process.\r\n */\r\nexport const enum VNDispAction\r\n{\r\n\t/**\r\n\t * Either it is not yet known what to do with the node itself or this is a stem node; that is,\r\n\t * only the node's children should be updated.\r\n\t */\r\n\tUnknown = 0,\r\n\r\n\t/**\r\n\t * The new node should be inserted. This means that either there was no counterpart old node\r\n\t * found or the found node cannot be used to update the old one nor can the old node be reused\r\n\t * by the new one (e.g. they are of different type).\r\n\t */\r\n\tInsert = 1,\r\n\r\n\t/**\r\n\t * The new node should be used to update the old node. This value is also used for InstanceVN\r\n\t * nodes if the old and the new are the same node.\r\n\t */\r\n\tUpdate = 2,\r\n}\r\n\r\n\r\n\r\n/**\r\n * The VNDispGroup class describes a group of consecutive VNDisp objects correspponding to the\r\n * sequence of sub-nodes. The group is described using indices of VNDisp objects in the\r\n * subNodeDisp field of the parent VNDisp object.\r\n */\r\nexport class VNDispGroup\r\n{\r\n\t/** parent VNDisp to which this group belongs */\r\n\tpublic parentDisp: VNDisp;\r\n\t\r\n\t/** Action to be performed on the nodes in the group */\r\n\tpublic action: VNDispAction;\r\n\r\n\t/** Index of the first VNDisp in the group */\r\n\tpublic first: number;\r\n\r\n\t/** Index of the last VNDisp in the group */\r\n\tpublic last: number;\r\n\r\n\t/** Number of nodes in the group. */\r\n\tpublic get count(): number { return this.last - this.first + 1 };\r\n\r\n\t/** First DOM node in the group - will be known after the nodes are physically updated */\r\n\tpublic firstDN: DN;\r\n\r\n\t/** First DOM node in the group - will be known after the nodes are physically updated */\r\n\tpublic lastDN: DN;\r\n\r\n\r\n\r\n\tconstructor( parentDisp: VNDisp, action: VNDispAction, first: number, last?: number)\r\n\t{\r\n\t\tthis.parentDisp = parentDisp;\r\n\t\tthis.action = action;\r\n\t\tthis.first = first;\r\n\t\tthis.last = last;\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Determines first and last DOM nodes for the group. This method is invoked only after the\r\n\t * nodes were phisically updated/inserted and we can obtain their DOM nodes.\r\n\t */\r\n\tpublic determineDNs()\r\n\t{\r\n\t\tlet disp: VNDisp;\r\n\t\tlet vn: VN;\r\n\t\tfor( let i = this.first; i <= this.last; i++)\r\n\t\t{\r\n\t\t\tdisp = this.parentDisp.subNodeDisps[i];\r\n\t\t\tvn = this.action === VNDispAction.Update ? disp.oldVN : disp.newVN;\r\n\t\t\tthis.firstDN = getFirstDN( vn);\r\n\t\t\tif (this.firstDN)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tfor( let i = this.last; i >= this.first; i--)\r\n\t\t{\r\n\t\t\tdisp = this.parentDisp.subNodeDisps[i];\r\n\t\t\tvn = this.action === VNDispAction.Update ? disp.oldVN : disp.newVN;\r\n\t\t\tthis.lastDN = getLastDN( vn);\r\n\t\t\tif (this.lastDN)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * If a node has more than this number of sub-nodes, then we build groups. The idea is that\r\n * otherwise, the overhead of building groups is not worth it.\r\n */\r\nconst NO_GROUP_THRESHOLD = 8;\r\n\r\n\r\n\r\n/**\r\n * The VNDisp class is a recursive structure that describes a disposition for a node and its\r\n * sub-nodes during the reconciliation process.\r\n */\r\nexport class VNDisp\r\n{\r\n\tconstructor( newVN: VN, action = VNDispAction.Unknown, oldVN?: VN)\r\n\t{\r\n\t\tthis.action = action;\r\n\t\tthis.newVN = newVN;\r\n\t\tthis.oldVN = oldVN;\r\n\t}\r\n\r\n\t/** Action to be performed on the node */\r\n\tpublic action: VNDispAction;\r\n\r\n\t/** New virtual node to insert or to update an old node */\r\n\tpublic newVN: VN;\r\n\r\n\t/** Old virtual node to be updated. This is only used for the Update action. */\r\n\tpublic oldVN: VN;\r\n\r\n\t/** Disposition flags for the Update action. This is not used for the Insert actions. */\r\n\tpublic updateDisp: VNUpdateDisp;\r\n\r\n\t/**\r\n\t * Array of disposition objects for sub-nodes. This includes nodes to be updated\r\n\t * and to be inserted.\r\n\t */\r\n\tpublic subNodeDisps: VNDisp[];\r\n\r\n\t/** Array of sub-nodes that should be removed during update of the sub-nodes. */\r\n\tpublic subNodesToRemove: VN[];\r\n\r\n\t/** Array of groups of sub-nodes that should be updated or inserted. */\r\n\tpublic subNodeGroups: VNDispGroup[];\r\n\r\n\r\n\r\n\t/**\r\n\t * Compares old and new chains of sub-nodes and determines what nodes should be created, deleted\r\n\t * or updated. The result is remembered as an array of VNDisp objects for each sub-node and as\r\n\t * array of old sub-nodes that should be deleted. In addition, the new sub-nodes are divided\r\n\t * into groups of consecutive nodes that should be updated and of nodes that should be inserted.\r\n\t * The groups are built in a way so that if a node should be moved, its entire group is moved.\r\n\t */\r\n\tpublic buildSubNodeDispositions(): void\r\n\t{\r\n\t\t// render the new content\r\n\t\tlet newChain = createVNChainFromContent( this.oldVN.render());\r\n\t\tlet newLen = newChain ? newChain.length : 0;\r\n\r\n\t\tlet oldChain = this.oldVN.subNodes;\r\n\t\tlet oldLen = oldChain ? oldChain.length : 0;\r\n\r\n\t\t// if either old or new or both chains are empty, we do special things\r\n\t\tif (newLen === 0 && oldLen === 0)\r\n\t\t{\r\n\t\t\t// both chain are empty - do nothing\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (newLen === 0)\r\n\t\t{\r\n\t\t\t// new chain is empty - delete all old nodes\r\n\t\t\tthis.subNodesToRemove = oldChain;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (oldLen === 0)\r\n\t\t{\r\n\t\t\t// old chain is empty - insert all new nodes\r\n\t\t\tthis.subNodeDisps = newChain.map( newVN => new VNDisp( newVN, VNDispAction.Insert));\r\n\t\t\tif (newLen > NO_GROUP_THRESHOLD)\r\n\t\t\t\tthis.subNodeGroups = [new VNDispGroup( this, VNDispAction.Insert, 0, newLen - 1)];\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// determine whether recycling of non-matching old keyed sub-nodes by non-matching new\r\n\t\t// keyed sub-nodes is allowed. If update strategy is not defined for the node, the\r\n\t\t// recycling is allowed.\r\n\t\tlet allowKeyedNodeRecycling = true;\r\n\t\tlet updateStrategy = this.oldVN ? this.oldVN.updateStrategy : undefined;\r\n\t\tif (updateStrategy && updateStrategy.allowKeyedNodeRecycling !== undefined)\r\n\t\t\tallowKeyedNodeRecycling = updateStrategy.allowKeyedNodeRecycling;\r\n\r\n\t\t// process the special case with a single sub-node in both old and new chains just\r\n\t\t// to avoid creating temporary structures\r\n\t\tif (newLen === 1 && oldLen === 1)\r\n\t\t{\r\n\t\t\tlet newVN = newChain[0];\r\n\t\t\tlet oldVN = oldChain[0];\r\n\t\t\tlet disp = new VNDisp( newVN);\r\n\t\t\tthis.subNodeDisps = [disp];\r\n\t\t\tif (oldVN === newVN ||\r\n\t\t\t\t((allowKeyedNodeRecycling || newVN.key === oldVN.key) && isUpdatePossible( oldVN, newVN)))\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Update;\r\n\t\t\t\tdisp.oldVN = oldVN;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Insert;\r\n\t\t\t\tthis.subNodesToRemove = [oldVN];\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// we are here if both old and new chains contain more than one node; therefore, the map of\r\n\t\t// keyed sub-nodes exists (although it might be empty).\r\n\t\tlet oldMap = this.oldVN.keyedSubNodes;\r\n\t\tlet oldMapSize = oldMap ? oldMap.size : 0;\r\n\r\n\t\t// prepare arrays for VNDisp objects for new nodes and for old nodes to be removed\r\n\t\tthis.subNodeDisps = new Array( newLen);\r\n\t\tthis.subNodesToRemove = [];\r\n\r\n\t\t// if the number of nodes in the old map is equal to the total number of old nodes, that\r\n\t\t// means that all old nodes are keyed. If this is the case AND recycling of keyed nodes\r\n\t\t// is not allowed, we will not need to put unkeyed or keyed but unmatched new nodes aside.\r\n\t\t// We know that they will have to be inserted.\r\n\t\tif (oldMapSize === oldLen && !allowKeyedNodeRecycling)\r\n\t\t\tthis.matchOldKeyedOnly( oldMap, newChain, newLen, newLen > NO_GROUP_THRESHOLD);\r\n\t\telse if (oldMapSize === 0 && allowKeyedNodeRecycling)\r\n\t\t\tthis.matchOldNonKeyedOnly( oldChain, oldLen, newChain, newLen, newLen > NO_GROUP_THRESHOLD);\r\n\t\telse\r\n\t\t\tthis.matchOldMixed( oldChain, oldLen, oldMap, newChain, newLen, allowKeyedNodeRecycling, newLen > NO_GROUP_THRESHOLD);\r\n\r\n\t\tif (this.subNodesToRemove.length === 0)\r\n\t\t\tthis.subNodesToRemove = undefined;\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * This method is invoked when we know that all old nodes have keys and the recycling of keyed\r\n\t * nodes is NOT allowed. Therefore, when we try to match new nodes to old ones we know that\r\n\t * non-keyed or keyed but unmatched new nodes will be marked for insertion. We also can build\r\n\t * groups (if requested) in the same loop.\r\n\t */\r\n\tprivate matchOldKeyedOnly( oldMap: Map<any,VN>, newChain: VN[], newLen: number, buildGroups: boolean): void\r\n\t{\r\n\t\t// declare variables that will be used throughout the following code\r\n\t\tlet disp: VNDisp, oldVN: VN, newVN: VN, key: any, action: VNDispAction, group: VNDispGroup;\r\n\r\n\t\t// if we need to build groups, prepare array of groups\r\n\t\tif (buildGroups)\r\n\t\t\tthis.subNodeGroups = [];\r\n\r\n\t\t// Loop over new nodes, create VNDisp structures try to match new nodes to old ones and\r\n\t\t// mark unkeyed or keyed but unmatched new nodes for insertion. On each iteration decide\r\n\t\t// whether we need to open a new group or put the new node into the existing group or\r\n\t\t// close the existing group and open a new one.\r\n\t\tfor( let i = 0; i < newLen; i++)\r\n\t\t{\r\n\t\t\tnewVN = newChain[i];\r\n\t\t\tdisp = this.subNodeDisps[i] = new VNDisp( newVN);\r\n\t\t\tkey = newVN.key;\r\n\r\n\t\t\t// decide what to do with the new node\r\n\t\t\tif (key === undefined)\r\n\t\t\t\taction = VNDispAction.Insert;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\toldVN = oldMap.get( key)\r\n\t\t\t\tif (oldVN === undefined)\r\n\t\t\t\t\taction = VNDispAction.Insert;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (oldVN === newVN || isUpdatePossible( oldVN, newVN))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\taction = VNDispAction.Update;\r\n\t\t\t\t\t\tdisp.oldVN = oldVN;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\taction = VNDispAction.Insert;\r\n\t\t\t\t\t\tthis.subNodesToRemove.push(oldVN);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// remove the old node from the map - this way the old nodes remaining in the\r\n\t\t\t\t\t// map are those that are unmatched.\r\n\t\t\t\t\toldMap.delete( key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tdisp.action = action;\r\n\r\n\t\t\tif (buildGroups)\r\n\t\t\t{\r\n\t\t\t\tif (!group)\r\n\t\t\t\t{\r\n\t\t\t\t\t// open a new group\r\n\t\t\t\t\tgroup = new VNDispGroup( this, action, i);\r\n\t\t\t\t\tthis.subNodeGroups.push( group);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (action !== group.action)\r\n\t\t\t\t{\r\n\t\t\t\t\t// close the group with the previous index and open a new group. Note that we\r\n\t\t\t\t\t// cannot be here for a node that starts a new group because for such node\r\n\t\t\t\t\t// disp.action === groupAction.\r\n\t\t\t\t\tgroup.last = i - 1;\r\n\t\t\t\t\tgroup = new VNDispGroup( this, action, i);\r\n\t\t\t\t\tthis.subNodeGroups.push( group);\r\n\t\t\t\t}\r\n\t\t\t\telse if (action === VNDispAction.Update)\r\n\t\t\t\t{\r\n\t\t\t\t\t// an \"update\" or \"none\" node is out-of-order and should close the current group if\r\n\t\t\t\t\t// its next sibling in the new list is different from the next sibling in the old list.\r\n\t\t\t\t\t// The last node will close the last group after the loop.\r\n\t\t\t\t\tif (i > 0 && this.subNodeDisps[i-1].oldVN !== oldVN.prev)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// close the group with the previous index and open new group.\r\n\t\t\t\t\t\tgroup.last = i - 1;\r\n\t\t\t\t\t\tgroup = new VNDispGroup( this, action, i);\r\n\t\t\t\t\t\tthis.subNodeGroups.push( group);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// all consecutive \"insert\" nodes belong to the same group so we just wait for the\r\n\t\t\t\t// next node\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// close the last group if requested to build groups (only in this case we may have a group object)\r\n\t\tif (group)\r\n\t\t\tgroup.last = newLen - 1;\r\n\r\n\t\t// if we have old nodes left, they should be removed\r\n\t\toldMap.forEach( oldVN => this.subNodesToRemove.push( oldVN));\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * This method is invoked when we know that none of the old nodes have keys and the recycling of keyed\r\n\t * nodes IS allowed. Therefore, we try to match new nodes to old ones by index. We also can build\r\n\t * groups (if requested) in the same loop.\r\n\t */\r\n\tprivate matchOldNonKeyedOnly( oldChain: VN[], oldLen: number, newChain: VN[], newLen: number, buildGroups: boolean): void\r\n\t{\r\n\t\t// declare variables that will be used throughout the following code\r\n\t\tlet disp: VNDisp, oldVN: VN, newVN: VN, key: any;\r\n\r\n\t\t// Loop over new nodes, create VNDisp structures and try to match new and old nodes by\r\n\t\t// index.\r\n\t\tlet i = 0;\r\n\t\tfor( ; i < newLen && i < oldLen; i++)\r\n\t\t{\r\n\t\t\tnewVN = newChain[i];\r\n\t\t\tdisp = this.subNodeDisps[i] = new VNDisp( newVN);\r\n\t\t\toldVN = oldChain[i];\r\n\r\n\t\t\t// decide what to do with the new node\r\n\t\t\tif (oldVN === newVN || isUpdatePossible( oldVN, newVN))\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Update;\r\n\t\t\t\tdisp.oldVN = oldVN;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Insert;\r\n\t\t\t\tthis.subNodesToRemove.push(oldVN);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// remaining new nodes should be inserted\r\n\t\tfor( let j = i; j < newLen; j++)\r\n\t\t\tthis.subNodeDisps[j] = new VNDisp( newChain[j], VNDispAction.Insert);\r\n\r\n\t\t// remaining old nodes should be removed\r\n\t\tfor( let j = i; j < oldLen; j++)\r\n\t\t\tthis.subNodesToRemove.push( oldChain[j]);\r\n\r\n\t\tif (buildGroups)\r\n\t\t\tthis.buildSubNodeGroups();\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * This method is invoked when we know that not all old nodes have keys or the recycling of\r\n\t * keyed nodes is allowed. Therefore, when we have a non-keyed or keyed but unmatched new\r\n\t * node, we first put it aside and only after we went over all new nodes we can decide\r\n\t * what to do with those that we put aside. Also, only after we went over all new nodes we\r\n\t * can build groups if requested.\r\n\t */\r\n\tprivate matchOldMixed( oldChain: VN[], oldLen: number, oldMap: Map<any,VN>, newChain: VN[],\r\n\t\t\t\t\tnewLen: number, allowKeyedNodeRecycling: boolean, buildGroups: boolean): void\r\n\t{\r\n\t\t\t// declare variables that will be used throughout the following code\r\n\t\tlet disp: VNDisp, oldVN: VN, newVN: VN, key: any;\r\n\r\n\t\t// Loop over new nodes, create VNDisp structures try to match new nodes to old ones and\r\n\t\t// put unmatched new nodes aside\r\n\t\tlet newUnmatchedDisps: VNDisp[] = [];\r\n\t\tfor( let i = 0; i < newLen; i++)\r\n\t\t{\r\n\t\t\tnewVN = newChain[i];\r\n\t\t\tdisp = this.subNodeDisps[i] = new VNDisp( newVN);\r\n\t\t\tkey = newVN.key;\r\n\r\n\t\t\tif (key === undefined)\r\n\t\t\t{\r\n\t\t\t\t// put the unkeyed new node aside\r\n\t\t\t\tnewUnmatchedDisps.push( disp);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\toldVN = oldMap.get( key)\r\n\t\t\t\tif (oldVN === undefined)\r\n\t\t\t\t{\r\n\t\t\t\t\t// if recycling allowed we put unmatched node aside; otherwise, we indicate that\r\n\t\t\t\t\t// it should be inserted\r\n\t\t\t\t\tif (allowKeyedNodeRecycling)\r\n\t\t\t\t\t\tnewUnmatchedDisps.push( disp);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdisp.action = VNDispAction.Insert;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (oldVN === newVN || isUpdatePossible( oldVN, newVN))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdisp.action = VNDispAction.Update;\r\n\t\t\t\t\t\tdisp.oldVN = oldVN;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdisp.action = VNDispAction.Insert;\r\n\t\t\t\t\t\tthis.subNodesToRemove.push(oldVN);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// remove the old node from the map - this way the old nodes remaining in the\r\n\t\t\t\t\t// map are those that are unmatched.\r\n\t\t\t\t\toldMap.delete( key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// loop over old sub-nodes, skip already matched ones and try to match others to the\r\n\t\t// yet-unmatched new nodes. Unmatched old nodes are those that are either unkeyed or\r\n\t\t// the keyed ones that are still in the oldMap.\r\n\t\tlet iOld = 0, iNew = 0, newUnmatchedLen = newUnmatchedDisps.length;\r\n\t\twhile( iOld < oldLen && iNew < newUnmatchedLen)\r\n\t\t{\r\n\t\t\t// skip already matched keyed nodes\r\n\t\t\toldVN = oldChain[iOld++];\r\n\t\t\tif (oldVN.key !== undefined && !oldMap.has( oldVN.key))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tdisp = newUnmatchedDisps[iNew++];\r\n\t\t\tnewVN = disp.newVN;\r\n\r\n\t\t\t// if recycling is not allowed and either old or new nodes is keyed, insert new and remove old\r\n\t\t\tif (!allowKeyedNodeRecycling && (oldVN.key !== undefined || newVN.key !== undefined))\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Insert;\r\n\t\t\t\tthis.subNodesToRemove.push( oldVN);\r\n\t\t\t}\r\n\t\t\telse if (isUpdatePossible( oldVN, newVN))\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Update;\r\n\t\t\t\tdisp.oldVN = oldVN;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdisp.action = VNDispAction.Insert;\r\n\t\t\t\tthis.subNodesToRemove.push(oldVN);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if we have new nodes left, they should be inserted\r\n\t\tfor( let j = iNew; j < newUnmatchedLen; j++)\r\n\t\t\tnewUnmatchedDisps[j].action = VNDispAction.Insert;\r\n\r\n\t\t// if we have old nodes left, they should be removed\r\n\t\tfor( let j = iOld; j < oldLen; j++)\r\n\t\t{\r\n\t\t\t// skip already matched keyed nodes\r\n\t\t\toldVN = oldChain[j];\r\n\t\t\tif (oldVN.key !== undefined && !oldMap.has( oldVN.key))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tthis.subNodesToRemove.push( oldVN);\r\n\t\t}\r\n\r\n\t\tif (buildGroups)\r\n\t\t\tthis.buildSubNodeGroups();\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * From a flat list of new sub-nodes builds groups of consecutive nodes that should be either\r\n\t * updated or inserted.\r\n\t */\r\n\tprivate buildSubNodeGroups(): void\r\n\t{\r\n\t\t// we are here only if we have some number of sub-node dispositions\r\n\t\tlet count = this.subNodeDisps.length;\r\n\r\n///////////////\r\n//////////////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////\r\n//////////////////////////////////////////////////\r\n///////////\r\n////////////\r\n\r\n\t\t// create array of groups and create the first group starting from the first node\r\n\t\tthis.subNodeGroups = [];\r\n\t\tlet group: VNDispGroup = new VNDispGroup( this, this.subNodeDisps[0].action, 0);\r\n\t\tthis.subNodeGroups.push( group);\r\n\r\n\t\t// loop over sub-nodes and on each iteration decide whether we need to open a new group\r\n\t\t// or put the current node into the existing group or close the existing group and open\r\n\t\t// a new one.\r\n\t\tlet action: VNDispAction;\r\n\t\tlet disp: VNDisp;\r\n\t\tfor( let i = 1; i < count; i++)\r\n\t\t{\r\n\t\t\tdisp = this.subNodeDisps[i];\r\n\t\t\taction = disp.action;\r\n\t\t\tif (action !== group.action)\r\n\t\t\t{\r\n\t\t\t\t// close the group with the previous index. Decrement the iterating index so that\r\n\t\t\t\t// the next iteration will open a new group. Note that we cannot be here for a node\r\n\t\t\t\t// that starts a new group because for such node disp.action === groupAction.\r\n\t\t\t\tgroup.last = i - 1;\r\n\t\t\t\tgroup = new VNDispGroup( this, action, i);\r\n\t\t\t\tthis.subNodeGroups.push( group);\r\n\t\t\t}\r\n\t\t\telse if (action === VNDispAction.Update)\r\n\t\t\t{\r\n\t\t\t\t// an \"update\" or \"none\" node is out-of-order and should close the current group if\r\n\t\t\t\t// its next sibling in the new list is different from the next sibling in the old list.\r\n\t\t\t\t// The last node will close the last group after the loop.\r\n\t\t\t\tif (this.subNodeDisps[i-1].oldVN !== disp.oldVN.prev)\r\n\t\t\t\t{\r\n\t\t\t\t\t// close the group with the current index.\r\n\t\t\t\t\tgroup.last = i - 1;\r\n\t\t\t\t\tgroup = new VNDispGroup( this, action, i);\r\n\t\t\t\t\tthis.subNodeGroups.push( group);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// all consecutive \"insert\" nodes belong to the same group so we just wait for the\r\n\t\t\t// next node\r\n\t\t}\r\n\r\n\t\t// close the last group\r\n\t\tif (group !== undefined)\r\n\t\t\tgroup.last = count - 1;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Determines whether update of the given old node from the given new node is possible. Update\r\n * is possible if the types of nodes are the same and either the isUpdatePossible method is not\r\n * defined on the old node or it returns true.\r\n */\r\nfunction isUpdatePossible( oldVN: VN, newVN: VN): boolean\r\n{\r\n\treturn (oldVN.type === newVN.type &&\r\n\t\t\t(oldVN.isUpdatePossible === undefined || oldVN.isUpdatePossible( newVN)));\r\n\r\n}\r\n","import * as mim from \"../api/mim\"\r\nimport {VNBase} from \"./VNBase\"\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Information kept by Root virtual node about service export functionations and subscriptions. The same\r\n// service can be published and subscribed to by multiple nodes.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass ServiceInfo\r\n{\r\n\tpublishingVNs: Set<VNBase> = new Set<VNBase>();\r\n\tsubscribedVNs: Set<VNBase> = new Set<VNBase>();\r\n}\r\n\r\n// Map of service IDs to sets of virtual nodes that subscribed to this service.\r\nlet s_serviceInfos = new Map<string,ServiceInfo>();\r\n\r\n\r\n\r\n// Informs that a service with the given ID was published by the given node.\r\nexport function notifyServicePublished( id: string, sourceVN: VNBase): void\r\n{\r\n\tlet info: ServiceInfo = s_serviceInfos.get( id);\r\n\tif (info === undefined)\r\n\t{\r\n\t\tinfo = new ServiceInfo();\r\n\t\ts_serviceInfos.set( id, info);\r\n\t}\r\n\r\n\tinfo.publishingVNs.add( sourceVN);\r\n\r\n\t// notify all subscribed nodes that information about the service has changed\r\n\tfor( let vn of info.subscribedVNs)\r\n\t\tvn.notifyServiceChanged( id);\r\n}\r\n\r\n\r\n\r\n// Informs that a service with the given ID was unpublished by the given node.\r\nexport function notifyServiceUnpublished( id: string, sourceVN: VNBase): void\r\n{\r\n\tlet info: ServiceInfo = s_serviceInfos.get( id);\r\n\tif (info === undefined)\r\n\t\treturn;\r\n\r\n\tinfo.publishingVNs.delete( sourceVN);\r\n\r\n\tif (info.publishingVNs.size === 0 && info.subscribedVNs.size === 0)\r\n\t\ts_serviceInfos.delete( id);\r\n\telse\r\n\t{\r\n\t\t// notify all subscribed nodes that information about the service has changed\r\n\t\tfor( let vn of info.subscribedVNs)\r\n\t\t\tvn.notifyServiceChanged( id);\r\n\t}\r\n}\r\n\r\n\r\n\r\n// Informs that the given node has subscribed to a service with the given ID.\r\nexport function notifyServiceSubscribed( id: string, sourceVN: VNBase): void\r\n{\r\n\tlet info: ServiceInfo = s_serviceInfos.get( id);\r\n\tif (info === undefined)\r\n\t{\r\n\t\tinfo = new ServiceInfo();\r\n\t\ts_serviceInfos.set( id, info);\r\n\t}\r\n\r\n\tinfo.subscribedVNs.add( sourceVN);\r\n}\r\n\r\n\r\n\r\n// Informs that the given node has unsubscribed from a service with the given ID.\r\nexport function notifyServiceUnsubscribed( id: string, sourceVN: VNBase): void\r\n{\r\n\tlet info: ServiceInfo = s_serviceInfos.get( id);\r\n\tif (info === undefined)\r\n\t\treturn;\r\n\r\n\tinfo.subscribedVNs.delete( sourceVN);\r\n\r\n\tif (info.publishingVNs.size === 0 && info.subscribedVNs.size === 0)\r\n\t\ts_serviceInfos.delete( id);\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {VN, VNUpdateDisp} from \"./VN\"\r\nimport {ClassCompVN} from \"./ClassCompVN\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The class InstanceVN is a node that holds an instance of an IComponent-implementing object.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class IndependentCompVN extends ClassCompVN<mim.IComponent> implements mim.IIndependentCompVN\r\n{\r\n\tconstructor( comp: mim.IComponent)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.type = mim.VNType.IndependentComp;\r\n\t\tthis.comp = comp;\r\n\t};\r\n\r\n\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic get name(): string\r\n\t{\r\n\t\t// components can define the getDisplayName method; if they don't then the default name\r\n\t\t// is the component's constructor name\r\n\t\tif (this.comp.getDisplayName)\r\n\t\t\treturn this.comp.getDisplayName();\r\n\t\telse\r\n\t\t\treturn this.comp.constructor.name;\r\n\t}\r\n\r\n\r\n\r\n\t// Node's key. The derived classes set it based on their respective content. A key\r\n\t// can be of any type. The instance of our component is the key.\r\n\tpublic get key(): any { return this.comp; }\r\n\r\n\r\n\r\n\t// Creates internal stuctures of the virtual node so that it is ready to produce children.\r\n\t// This method is called right after the node has been constructed.\r\n\t// This method is part of the Render phase.\r\n\tpublic willMount(): void\r\n\t{\r\n\t\tthis.willMountInstance( this.comp);\r\n\t}\r\n\r\n\r\n\r\n\t// This method is called before the content of node and all its sub-nodes is removed from the\r\n\t// DOM tree.\r\n\t// This method is part of the render phase.\r\n\tpublic willUnmount(): void\r\n\t{\r\n\t\tthis.willUnmountInstance( this.comp);\r\n\t}\r\n\r\n\r\n\r\n\t// Prepares this node to be updated from the given node. This method is invoked only if update\r\n\t// happens as a result of rendering the parent nodes. The newVN parameter is guaranteed to\r\n\t// point to a VN of the same type as this node. The returned object indicates whether children\r\n\t// should be updated and whether the commitUpdate method should be called.\r\n\t// This method is part of the Render phase.\r\n\tpublic prepareUpdate( newVN: VN): VNUpdateDisp\r\n\t{\r\n\t\t// if it is the same component instance, we don't need to do anything\r\n\t\tlet newComp = (newVN as IndependentCompVN).comp;\r\n\t\tlet needsUpdating = this.comp !== newComp;\r\n\r\n\t\t// if the coponent instance are different, then we need to prepare the new instance for\r\n\t\t// mounting and the old one for unmounting.\r\n\t\tif (needsUpdating)\r\n\t\t{\r\n\t\t\tthis.willMountInstance( newComp);\r\n\t\t\tthis.willUnmountInstance( this.comp);\r\n\t\t\tthis.comp = newComp;\r\n\t\t}\r\n\r\n\t\treturn VNUpdateDisp.getStockValue( false, needsUpdating);\r\n\t}\r\n\r\n\r\n\r\n\t// Notifies the given component that ir will be mounted.\r\n\tprivate willMountInstance( comp: mim.IComponent): void\r\n\t{\r\n\t\tcomp.vn = this;\r\n\r\n\t\tif (comp.willMount)\r\n\t\t\tcomp.willMount();\r\n\r\n///////////////////\r\n///////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// Notifies the given component that it will be unmounted.\r\n\tprivate willUnmountInstance( comp: mim.IComponent): void\r\n\t{\r\n\t\tif (comp.willUnmount)\r\n\t\t\tcomp.willUnmount();\r\n\r\n\t\tcomp.vn = undefined;\r\n\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {VN, VNUpdateDisp} from \"./VN\"\r\nimport {ClassCompVN} from \"./ClassCompVN\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Represents a component implementing the IComponent<> interface.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class ManagedCompVN extends ClassCompVN<mim.IComponent> implements mim.IManagedCompVN\r\n{\r\n\t// Type of the class-based component.\r\n\tpublic compClass: mim.IComponentClass;\r\n\r\n\r\n\r\n\tconstructor( compClass: mim.IComponentClass, props: any, children: any[])\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.type = mim.VNType.ManagedComp;\r\n\t\tthis.compClass = compClass;\r\n\r\n\t\t// copy properties to our own object excluding framework-handled key and ref\r\n\t\tthis.props = {};\r\n\t\tif (props)\r\n\t\t{\r\n\t\t\tfor( let propName in props)\r\n\t\t\t{\r\n\t\t\t\tlet propVal: any = props[propName];\r\n\t\t\t\tif (propVal === undefined || propVal === null)\r\n\t\t\t\t{\r\n\t\t\t\t\t// ignore properties with values undefined and null\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (propName === \"key\")\r\n\t\t\t\t{\r\n\t\t\t\t\t// remember key property but don't copy it to this.props object\r\n\t\t\t\t\tthis.key = propVal;\r\n\t\t\t\t}\r\n\t\t\t\telse if (propName === \"ref\")\r\n\t\t\t\t{\r\n\t\t\t\t\t// remember ref property but don't copy it to this.props object\r\n\t\t\t\t\tthis.ref = propVal;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.props[propName] = propVal;\r\n\t\t\t}\r\n\r\n\t\t\t// if key property was not specified, use id; if id was not specified key will remain\r\n\t\t\t// undefined.\r\n\t\t\tif (this.key === undefined)\r\n\t\t\t\tthis.key = props.id;\r\n\t\t}\r\n\r\n\t\t// remember children as part of props\r\n\t\tthis.props.children = children;\r\n\t};\r\n\r\n\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic get name(): string\r\n\t{\r\n\t\t// components can define the getDisplayName method; if they don't then the default name\r\n\t\t// is the component's constructor name plus key if defined. Note that component instance\r\n\t\t// might not be created yet when this method is called\r\n\t\tif (this.comp && this.comp.getDisplayName)\r\n\t\t\treturn this.comp.getDisplayName();\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet name = this.compClass.name;\r\n\t\t\tif (this.key != null)\r\n\t\t\t\tname += \"@\" + this.key;\r\n\r\n\t\t\treturn name;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Creates internal stuctures of the virtual node so that it is ready to produce children.\r\n\t// This method is called right after the node has been constructed.\r\n\t// This method is part of the Render phase.\r\n\tpublic willMount(): void\r\n\t{\r\n\t\t// create component instance\r\n\t\tthis.comp = new this.compClass( this.props);\r\n\t\tthis.comp.vn = this;\r\n\r\n\t\tif (this.comp.willMount)\r\n\t\t\tthis.comp.willMount();\r\n\r\n\t\t// set the reference value if specified\r\n\t\tif (this.ref !== undefined)\r\n\t\t\tmim.setRef( this.ref, this.comp);\r\n\r\n///////////////////\r\n///////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// This method is called before the content of node and all its sub-nodes is removed from the\r\n\t// DOM tree.\r\n\t// This method is part of the render phase.\r\n\tpublic willUnmount(): void\r\n\t{\r\n\t\t// unset the reference value if specified. We check whether the reference still points\r\n\t\t// to our component before setting it to undefined. If the same Ref object is used for\r\n\t\t// more than one components (and/or elements) it can happen that the reference is changed\r\n\t\t// before our component is unmounted.\r\n\t\tif (this.ref !== undefined)\r\n\t\t\tmim.setRef( this.ref, undefined, this.comp);\r\n\r\n\t\tif (this.comp.willUnmount)\r\n\t\t\tthis.comp.willUnmount();\r\n\r\n\t\tthis.comp.vn = undefined;\r\n\t\tthis.comp = undefined;\r\n\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the update of this node from the given node is possible. The newVN\r\n\t// parameter is guaranteed to point to a VN of the same type as this node.\r\n\tpublic isUpdatePossible( newVN: VN): boolean\r\n\t{\r\n\t\t// update is possible if the component class name is the same\r\n\t\treturn this.compClass === (newVN as ManagedCompVN).compClass;\r\n\t}\r\n\r\n\r\n\r\n\t// Updates this node from the given node. The newVN parameter is guaranteed to point to a\r\n\t// VN of the same type as this node. Returns true if updating sub-nodes is necessary and\r\n\t// false otherwise.\r\n\tpublic prepareUpdate( newVN: VN): VNUpdateDisp\r\n\t{\r\n\t\tlet newClassVN = newVN as ManagedCompVN;\r\n\r\n\t\t// let the component know about the new properties (if it is interested in them)\r\n\t\tlet shouldRender: boolean = true;\r\n\t\tif (this.comp.shouldUpdate !== undefined)\r\n\t\t\tshouldRender = this.comp.shouldUpdate( newClassVN.props);\r\n\r\n\t\t// if reference specification changed then set or unset it as necessary\r\n\t\tif (newClassVN.ref !== this.ref)\r\n\t\t{\r\n\t\t\t// remember the new reference object\r\n\t\t\tthis.ref = newClassVN.ref;\r\n\r\n\t\t\t// if reference is now specified, set it now; note that we already determined that\r\n\t\t\t// the reference object is different.\r\n\t\t\tif (this.ref !== undefined)\r\n\t\t\t\tmim.setRef( this.ref, this.comp);\r\n\t\t}\r\n\t\telse if (newClassVN.ref === undefined)\r\n\t\t{\r\n\t\t\t// we know that our reference is defined, so unset it\r\n\t\t\tmim.setRef( this.ref, undefined, this.comp);\r\n\t\t}\r\n\r\n\t\t// remeber the new value of the key property (even if it is the same)\r\n\t\tthis.key = newClassVN.key;\r\n\r\n\t\t// shallow copy the new properties from the other node to our object. This is needed\r\n\t\t// because the component got our props object in the constructor and will keep\r\n\t\t// working with it - especially if it doesn't implement the shouldUpdate method.\r\n\t\tObject.keys(this.props).forEach( key => delete this.props[key]);\r\n\t\tObject.assign( this.props, newClassVN.props);\r\n\r\n\t\t// since the rendering produced by a function may depend on factors beyond properties,\r\n\t\t// we always indicate that it is necessary to update the sub-nodes. The commitUpdate\r\n\t\t// method should NOT be called.\r\n\t\treturn VNUpdateDisp.getStockValue( false, shouldRender);\r\n\t}\r\n\r\n\r\n\r\n\t// Node's key. The derived classes set it based on their respective content. A key\r\n\t// can be of any type.\r\n\tpublic key: any;\r\n\r\n\t// Properties that were passed to the component.\r\n\tprivate props: any;\r\n\r\n\t// Reference to the component that is specified as a \"ref\" property. Reference object is\r\n\t// set when analyzing properties in the constructor and during update. Reference value is\r\n\t// set during mount and unset during unmount.\r\n\tprivate ref: mim.RefPropType<any>;\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {DN, VN, VNUpdateDisp} from \"./VN\"\r\nimport {VNBase} from \"./VNBase\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n/**\r\n * Represents a rendering function a.k.a. stateless component.\r\n */\r\nexport class FuncVN extends VNBase\r\n{\r\n\t/** Determines whether this node corresponds to a fragment placeholder. */\r\n\tpublic static isVNaFragment( vn: VN): boolean\r\n\t{\r\n\t\treturn (vn as FuncVN).func === mim.Fragment;\r\n\t}\r\n\r\n\r\n\r\n\tconstructor( func: mim.FuncCompType, props: any, children: any[])\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.type = mim.VNType.FuncComp;\r\n\t\tthis.func = func;\r\n\r\n\t\t// copy properties to our own object excluding framework-handled key\r\n\t\tthis.props = {};\r\n\t\tif (props)\r\n\t\t{\r\n\t\t\tfor( let propName in props)\r\n\t\t\t{\r\n\t\t\t\tlet propVal: any = props[propName];\r\n\t\t\t\tif (propVal === undefined || propVal === null)\r\n\t\t\t\t{\r\n\t\t\t\t\t// ignore properties with values undefined and null\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (propName === \"key\")\r\n\t\t\t\t{\r\n\t\t\t\t\t// remember key property but don't copy it to this.props object\r\n\t\t\t\t\tthis.key = propVal;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.props[propName] = propVal;\r\n\t\t\t}\r\n\r\n\t\t\t// if key property was not specified, use id; if id was not specified key will remain\r\n\t\t\t// undefined.\r\n\t\t\tif (this.key === undefined)\r\n\t\t\t\tthis.key = props.id;\r\n\t\t}\r\n\r\n\t\t// remember children as part of props\r\n\t\tthis.props.children = children;\r\n\t};\r\n\r\n\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic get name(): string\r\n\t{\r\n\t\t// node name is the function's name plus key (or id) if specified.\r\n\t\tlet name = this.func.name;\r\n\t\tif (this.key != null)\r\n\t\t\tname += \"@\" + this.key;\r\n\r\n\t\treturn name;\r\n\t}\r\n\r\n\r\n\r\n\t// Generates list of sub-nodes according to the current state\r\n\tpublic render(): any\r\n\t{\r\n//////////////////////\r\n////////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n///////////////////\r\n//////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\treturn this.func( this.props);\r\n\t}\r\n\r\n\r\n\r\n//////////////////\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////\r\n//////////////////////////\r\n///\r\n///////////////////////////////////////////////////////////////////\r\n///\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////\r\n//////////////\r\n/////////////////////////////////////////////\r\n////////////////////////////\r\n///\r\n/////////////////////////////////////////////////////////////////////\r\n///\r\n///////////\r\n\r\n\r\n\r\n\t// Determines whether the update of this node from the given node is possible. The newVN\r\n\t// parameter is guaranteed to point to a VN of the same type as this node.\r\n\tpublic isUpdatePossible( newVN: VN): boolean\r\n\t{\r\n\t\t// update is possible if it is the same function object\r\n\t\treturn this.func === (newVN as FuncVN).func;\r\n\t}\r\n\r\n\r\n\r\n\t// Prepares this node to be updated from the given node. This method is invoked only if update\r\n\t// happens as a result of rendering the parent nodes. The newVN parameter is guaranteed to\r\n\t// point to a VN of the same type as this node. The returned object indicates whether children\r\n\t// should be updated and whether the commitUpdate method should be called.\r\n\t// This method is part of the Render phase.\r\n\tpublic prepareUpdate( newVN: VN): VNUpdateDisp\r\n\t{\r\n\t\tlet newFuncVN = newVN as FuncVN;\r\n\r\n\t\t// remeber the new value of the key property (even if it is the same)\r\n\t\tthis.key = newFuncVN.key;\r\n\r\n\t\t// take properties from the new node\r\n\t\tthis.func = newFuncVN.func;\r\n\t\tthis.props = newFuncVN.props;\r\n\r\n\t\t// since the rendering produced by a function may depend on factors beyond properties,\r\n\t\t// we always indicate that it is necessary to update the sub-nodes. The commitUpdate\r\n\t\t// method should NOT be called.\r\n\t\treturn VNUpdateDisp.NoCommitDoRender;\r\n\t}\r\n\r\n\r\n\r\n\t// Function for a stateless component. The function is invoked during the rendering process.\r\n\tprivate func: mim.FuncCompType;\r\n\r\n\t// Properties that were passed to the component, function or element.\r\n\tprivate props: any;\r\n\r\n\t// Node's key. The derived classes set it based on their respective content. A key\r\n\t// can be of any type.\r\n\tpublic key: any;\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {DN, VN, VNUpdateDisp} from \"./VN\"\r\nimport {VNBase} from \"./VNBase\"\r\nimport {ElmAttr, AttrPropInfo, EventPropInfo, CustomAttrPropInfo, PropType, PropInfo} from \"../utils/ElmAttr\"\r\nimport {SvgElms} from \"../utils/SvgElms\";\r\nimport {deepCompare} from \"../utils/Utils\";\r\nimport {s_currentVN} from \"./Scheduler\"\r\nimport {ClassCompVN} from \"./ClassCompVN\";\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Represents a DOM element created using JSX.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class ElmVN extends VNBase implements mim.IElmVN\r\n{\r\n\t// Tag name of an Element.\r\n\tpublic elmName: string;\r\n\r\n\t// Instance of an Element. The instance is created when the node is rendered for the first\r\n\t// time.\r\n\tpublic elm: Element;\r\n\r\n\t// Flag indicating whether the Element is SVG (as opposed to HTLM). There are some SVG\r\n\t// elements that have the same name as regular elements (e.g. <a>). Therefore, in order to\r\n\t// determine whether this is an SVG or not we need to check the namespaceURI of the parent\r\n\t// (anchore) DOM node.\r\n\tpublic isSvg: boolean;\r\n\r\n\t// Component that created this element in its render method.\r\n\tpublic creator: mim.IComponent;\r\n\r\n\r\n\r\n\tconstructor( tagName: string, props: any, children: any[])\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.type = mim.VNType.Elm;\r\n\t\tthis.elmName = tagName;\r\n\t\tthis.props = props;\r\n\t\tthis.children = children;\r\n\r\n\t\t// the s_currentVN should point to the virtual node behind the class-based component\r\n\t\t// whose render method created this element node. We remember it and use it later to\r\n\t\t// bind event listeners.\r\n\t\tif (s_currentVN && s_currentVN instanceof ClassCompVN)\r\n\t\t\tthis.creator = s_currentVN.comp;\r\n\r\n\t\tif (props)\r\n\t\t{\r\n\t\t\t// get the key property. If key property was not specified, use id; if id was not\r\n\t\t\t// specified key will remain undefined.\r\n\t\t\tthis.key = props.key;\r\n\t\t\tif (this.key === undefined)\r\n\t\t\t\tthis.key = props.id;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n//////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n///////////\r\n\r\n\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic get name(): string\r\n\t{\r\n\t\t// node name is the element's name plus key (or id) if specified.\r\n\t\tlet name = this.elmName;\r\n\t\tif (this.key != null)\r\n\t\t\tname += \"@\" + this.key;\r\n\r\n\t\treturn name;\r\n\t}\r\n\r\n\r\n\r\n\t// Returns DOM node corresponding to the virtual node itself and not to any of its sub-nodes.\r\n\tpublic get ownDN(): DN { return this.elm; }\r\n\r\n\r\n\r\n\t// Generates list of sub-nodes according to the current state\r\n\tpublic render(): any\r\n\t{\r\n\t\treturn this.children;\r\n\t}\r\n\r\n\r\n\r\n\t// Creates and returns DOM node corresponding to this virtual node.\r\n\t// This method is part of the Commit phase.\r\n\tpublic mount(): DN\r\n\t{\r\n\t\t// determine whether this is an SVG or HTML element and create the element\r\n\t\tlet svgInfo = SvgElms.getSvgElmInfo( this.elmName);\r\n\t\tthis.isSvg = svgInfo !== undefined && (svgInfo !== true || this.anchorDN.namespaceURI.endsWith( \"svg\"));\r\n\t\tthis.elm = this.isSvg\r\n\t\t\t? this.elm = document.createElementNS( SvgElms.namespace, SvgElms.getElmName( svgInfo, this.elmName))\r\n\t\t\t: this.elm = document.createElement( this.elmName);\r\n\r\n\t\t// translate properties into attributes, events and custom attributes\r\n\t\tthis.parseProps();\r\n\r\n\t\tif (this.attrs)\r\n\t\t\tthis.addAttrs();\r\n\r\n\t\tif (this.events)\r\n\t\t\tthis.addEvents();\r\n\r\n\t\tif (this.customAttrs)\r\n\t\t\tthis.addCustomAttrs();\r\n\r\n\t\t// set the value of the reference (if specified)\r\n\t\tif (this.ref !== undefined)\r\n\t\t\tmim.setRef( this.ref, this.elm);\r\n\r\n///////////////////\r\n//////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\treturn this.elm;\r\n\t}\r\n\r\n\r\n\r\n\t// Releases reference to the DOM node corresponding to this virtual node.\r\n\t// This method is part of the Commit phase.\r\n\tpublic unmount(): void\r\n\t{\r\n\t\t// unset the reference value if specified. We check whether the reference still points\r\n\t\t// to our element before setting it to undefined. If the same Ref object is used for\r\n\t\t// more than one element (and/or components) it can happen that the reference is changed\r\n\t\t// before our element is unmounted.\r\n\t\tif (this.ref !== undefined)\r\n\t\t\tmim.setRef( this.ref, undefined, this.elm);\r\n\r\n////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////\r\n///////////////////\r\n////////////////////////\r\n////////////\r\n\r\n\t\t// terminate custom property handlers\r\n\t\tif (this.customAttrs)\r\n\t\t\tthis.removeCustomAttrs( true);\r\n\r\n\t\t// clean up\r\n\t\tthis.elm = null;\r\n\r\n///////////////////\r\n////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the update of this node from the given node is possible. The newVN\r\n\t// parameter is guaranteed to point to a VN of the same type as this node.\r\n\tpublic isUpdatePossible( newVN: VN): boolean\r\n\t{\r\n\t\t// update is possible if this is the same type of element; that is, it has the same\r\n\t\t// name.\r\n\t\treturn this.elmName === (newVN as ElmVN).elmName;\r\n\t}\r\n\r\n\r\n\r\n\t// Prepares this node to be updated from the given node. This method is invoked only if update\r\n\t// happens as a result of rendering the parent nodes. The newVN parameter is guaranteed to\r\n\t// point to a VN of the same type as this node. The returned object indicates whether children\r\n\t// should be updated and whether the commitUpdate method should be called.\r\n\t// This method is part of the Render phase.\r\n\tpublic prepareUpdate( newVN: VN): VNUpdateDisp\r\n\t{\r\n\t\t// commitUpdate method should be called if new props are different from the current ones\r\n\t\tlet shouldCommit = !deepCompare( this.props, (newVN as ElmVN).props);\r\n\r\n\t\t// render method should be called if either old or new node has children\r\n\t\tlet shouldRender = this.children && this.children.length > 0 ||\r\n\t\t\t\t\t(newVN as ElmVN).children && (newVN as ElmVN).children.length > 0;\r\n\r\n\t\t// remember the new props and children\r\n\t\tthis.props = (newVN as ElmVN).props;\r\n\t\tthis.children = (newVN as ElmVN).children;\r\n\r\n\t\treturn { shouldCommit, shouldRender };\r\n\t}\r\n\r\n\r\n\r\n\t// Commits updates made to this node to DOM.\r\n\tpublic commitUpdate( newVN: VN): void\r\n\t{\r\n\t\tconst newElmVN: ElmVN = newVN as ElmVN;\r\n\t\tnewElmVN.parseProps();\r\n\r\n\t\t// if reference specification changed then set or unset it as necessary\r\n\t\tif (newElmVN.ref !== this.ref)\r\n\t\t{\r\n\t\t\t// remember the new reference specification\r\n\t\t\tthis.ref = newElmVN.ref;\r\n\r\n\t\t\t// if reference is now specified, set it now; note that we already determined that\r\n\t\t\t// the reference object is different.\r\n\t\t\tif (this.ref !== undefined)\r\n\t\t\t\tmim.setRef( this.ref, this.elm);\r\n\t\t}\r\n\r\n\t\t// remeber the new value of the key property (even if it is the same)\r\n\t\tthis.key = newElmVN.key;\r\n\r\n\t\t// remeber the new value of the updateStrategy property (even if it is the same)\r\n\t\tthis.updateStrategy = newElmVN.updateStrategy;\r\n\r\n\t\tthis.updateAttrs( newElmVN.attrs);\r\n\t\tthis.updateEvents( newElmVN.events);\r\n\t\tthis.updateCustomAttrs( newElmVN.customAttrs);\r\n\t}\r\n\r\n\r\n\r\n\t// Goes over the original properties and puts them into the buckets of attributes, event\r\n\t// listeners and custom attributes.\r\n\tprivate parseProps(): void\r\n\t{\r\n\t\tif (!this.props)\r\n\t\t\treturn;\r\n\r\n\t\tlet propVal: any, propInfo: PropInfo, propType: PropType;\r\n\t\tfor( let propName in this.props)\r\n\t\t{\r\n\t\t\tif (propName === \"key\")\r\n\t\t\t{\r\n\t\t\t\t// ignore the key property because we already extracted it in the constructor\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpropVal = this.props[propName];\r\n\t\t\tif (propVal == null)\r\n\t\t\t{\r\n\t\t\t\t// ignore properties with values undefined and null\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse if (propName === \"ref\")\r\n\t\t\t{\r\n\t\t\t\t// remember ref property\r\n\t\t\t\tthis.ref = propVal;\r\n\t\t\t}\r\n\t\t\telse if (propName === \"updateStrategy\")\r\n\t\t\t{\r\n\t\t\t\t// remember updateStrategy property\r\n\t\t\t\tthis.updateStrategy = propVal;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// get information about the property and determine its type (regular attribute, event\r\n\t\t\t\t// or custom attribute). Note that getPropertyInfo may return null for most regular\r\n\t\t\t\t// attributes and events; in this case we will check the property value.\r\n\t\t\t\tpropInfo = ElmAttr.getPropertyInfo( propName);\r\n\t\t\t\tpropType = propInfo ? propInfo.type : isEventValue( propVal) ? PropType.Event : PropType.Attr;\r\n\r\n\t\t\t\tif (propType === PropType.Attr)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!this.attrs)\r\n\t\t\t\t\t\tthis.attrs = {};\r\n\r\n\t\t\t\t\tthis.attrs[propName] = { info: propInfo, val: propVal };\r\n\t\t\t\t}\r\n\t\t\t\telse if (propType === PropType.Event)\r\n\t\t\t\t{\r\n\t\t\t\t\tlet eventInfo = getPropAsEventRunTimeData( propInfo, propVal);\r\n\t\t\t\t\tif (eventInfo)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!this.events)\r\n\t\t\t\t\t\t\tthis.events = {}\r\n\r\n\t\t\t\t\t\tthis.events[propName] = eventInfo;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse // if (propType === PropType.CustomAttr)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!this.customAttrs)\r\n\t\t\t\t\t\tthis.customAttrs = {};\r\n\r\n\t\t\t\t\t// remember custome attributes value. Handler will be created later.\r\n\t\t\t\t\tthis.customAttrs[propName] = { info: propInfo as CustomAttrPropInfo, val: propVal,\r\n\t\t\t\t\t\t\t\t\thandler: undefined};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Adds DOM attributes to the Element.\r\n\tprivate addAttrs(): void\r\n\t{\r\n///////////////\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\tfor( let name in this.attrs)\r\n\t\t{\r\n\t\t\tlet rtd = this.attrs[name];\r\n\t\t\tElmAttr.setAttr( this.elm, name, rtd.info, rtd.val);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Updates DOM attributes of this Element.\r\n\tprivate updateAttrs( newAttrs: { [name: string]: AttrRunTimeData }): void\r\n\t{\r\n\t\t// \"cache\" several memebers for faster access\r\n\t\tlet elm = this.elm;\r\n\t\tlet oldAttrs = this.attrs;\r\n\r\n\t\t// loop over existing attributes, remove those that are not found among the new ones and\r\n\t\t// update those whose value has changed\r\n\t\tif (oldAttrs)\r\n\t\t{\r\n\t\t\tfor( let name in oldAttrs)\r\n\t\t\t{\r\n\t\t\t\tlet oldRTD = oldAttrs[name];\r\n\t\t\t\tlet newRTD = newAttrs ? newAttrs[name] : undefined;\r\n\t\t\t\tif (!newRTD || !newRTD.val)\r\n\t\t\t\t{\r\n\t\t\t\t\t// if there is no new property with the given name, remove the old property and\r\n\t\t\t\t\t// remove the attribute from the element\r\n\t\t\t\t\tElmAttr.removeAttr( elm, name, oldRTD.info);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// if the new property with the given name has a different value, remmeber this\r\n\t\t\t\t\t// value and set it to the attribute in the element\r\n\t\t\t\t\tElmAttr.updateAttr( elm, name, oldRTD.info, oldRTD.val, newRTD.val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// loop over new attributes; add those that are not found among the old ones\r\n\t\tif (newAttrs)\r\n\t\t{\r\n\t\t\tfor( let name in newAttrs)\r\n\t\t\t{\r\n\t\t\t\tif (oldAttrs && (name in oldAttrs))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tlet newRTD = newAttrs[name];\r\n\t\t\t\tElmAttr.setAttr( elm, name, newRTD.info, newRTD.val);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.attrs = newAttrs;\r\n\t}\r\n\r\n\r\n\r\n\t// Adds information about events to the Element.\r\n\tprivate addEvents(): void\r\n\t{\r\n///////////////\r\n////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\tfor( let name in this.events)\r\n\t\t\tthis.addEvent( name, this.events[name]);\r\n\t}\r\n\r\n\r\n\r\n\t// Using the given property name and its value set the appropriate attribute(s) on the\r\n\t// element. This method handles special cases of properties with non-trivial values.\r\n\tprivate addEvent( name: string, event: EventRunTimeData): void\r\n\t{\r\n\t\tevent.wrapper = this.createEventWrapper( event);\r\n\t\tthis.elm.addEventListener( name, event.wrapper, event.useCapture);\r\n\r\n///////////////////\r\n////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n///////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////\r\n//////////////////////////////\r\n///\r\n////////////////\r\n/////////////////////\r\n///////////////////////////////////////////////////////////////////////////\r\n/////////////\r\n\r\n////////////////////////////////\r\n///////////////////////////////////////////////\r\n///\r\n///////////\r\n\r\n\r\n\r\n\t// Removes the given event listener from the Element.\r\n\tprivate removeEvent( name: string, event: EventRunTimeData): void\r\n\t{\r\n\t\tthis.elm.removeEventListener( name, event.wrapper, event.useCapture);\r\n\r\n///////////////////\r\n//////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// Adds event listeners to the Element.\r\n\tprivate updateEvents( newEvents: { [name: string]: EventRunTimeData }): void\r\n\t{\r\n\t\tlet oldEvents = this.events;\r\n\r\n\t\t// loop over existing event listeners, remove those that are not found among the new\r\n\t\t// ones and update those whose value has changed\r\n\t\tif (oldEvents)\r\n\t\t{\r\n\t\t\tfor( let name in oldEvents)\r\n\t\t\t{\r\n\t\t\t\tlet oldEvent = oldEvents[name];\r\n\t\t\t\tlet newEvent = newEvents ? newEvents[name] : undefined;\r\n\t\t\t\tif (!newEvent)\r\n\t\t\t\t\tthis.removeEvent( name, oldEvent);\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.updateEvent( name, oldEvent, newEvent);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// loop over new event listeners and add those that are not found among the old ones\r\n\t\tif (newEvents)\r\n\t\t{\r\n\t\t\tfor( let name in newEvents)\r\n\t\t\t{\r\n\t\t\t\tif (oldEvents && (name in oldEvents))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tthis.addEvent( name, newEvents[name]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.events = newEvents;\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the old and the new values of the event listener are different and sets\r\n\t// the updated value. Returns true if update has been performed and false if no change has\r\n\t// been detected.\r\n\tprivate updateEvent( name: string, oldEvent: EventRunTimeData, newEvent: EventRunTimeData): boolean\r\n\t{\r\n\t\t// double-equal-sign for useCapture is on purpose, because useCapture can be undefined or boolean\r\n\t\tif (oldEvent.orgFunc === newEvent.orgFunc &&\r\n\t\t\toldEvent.that === newEvent.that &&\r\n\t\t\toldEvent.useCapture == newEvent.useCapture)\r\n\t\t{\r\n\t\t\tnewEvent.wrapper = oldEvent.wrapper;\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// remove old event listener\r\n\t\t\tthis.elm.removeEventListener( name, oldEvent.wrapper, oldEvent.useCapture);\r\n\r\n\t\t\t// create new wrapper and add it as event listener\r\n\t\t\tnewEvent.wrapper = this.createEventWrapper( newEvent);\r\n\t\t\tthis.elm.addEventListener( name, newEvent.wrapper, newEvent.useCapture);\r\n\r\n////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n/////////////\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Returns a wrapper function that will be used as an event listener. The wrapper is bound to\r\n\t// the instance of ElmVN and thus can intercept exceptions and process them using the standard\r\n\t// error service. Unless the original callback is already a bound function, it will be called\r\n\t// with \"this\" set to either the \"event.that\" object or, if the latter is undefined, to the\r\n\t// \"creator\" object, which is the class-based component that created the element i its render\r\n\t// method.\r\n\tprivate createEventWrapper( event: EventRunTimeData): mim.EventFuncType<Event>\r\n\t{\r\n\t\treturn this.wrapCallback( event.orgFunc, event.that ? event.that : this.creator);\r\n\t}\r\n\r\n\r\n\r\n\t// Creates custom attributes.\r\n\tprivate addCustomAttrs(): void\r\n\t{\r\n///////////////\r\n/////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\t// create and initialize custom property handlers\r\n\t\tfor( let name in this.customAttrs)\r\n\t\t{\r\n\t\t\tlet customAttr = this.customAttrs[name];\r\n\r\n\t\t\t// create custom property handler. If we cannot create the handler, remove the property\r\n\t\t\t// from our object.\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tcustomAttr.handler = new customAttr.info.handlerClass( this, customAttr.val, name);\r\n\t\t\t}\r\n\t\t\tcatch( err)\r\n\t\t\t{\r\n\t\t\t\tconsole.error( `Error creating handler for custom attribute '${name}': ${err.message}`);\r\n\t\t\t\tdelete this.customAttrs[name];\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Destroys custom attributes of this element.\r\n\tprivate removeCustomAttrs( isRemoval: boolean): void\r\n\t{\r\n///////////////\r\n/////////////////////////\r\n////////////////////////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\tfor( let name in this.customAttrs)\r\n\t\t{\r\n\t\t\tlet customAttr = this.customAttrs[name];\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tcustomAttr.handler.terminate( isRemoval);\r\n\t\t\t}\r\n\t\t\tcatch( err)\r\n\t\t\t{\r\n\t\t\t\tconsole.error( `Error terminating handler for custom attribute '${name}': ${err.message}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Updates custom attributes of this node.\r\n\tprivate updateCustomAttrs( newCustomAttrs: { [name: string]: CystomAttrRunTimeData }): void\r\n\t{\r\n\t\tlet oldCustomAttrs = this.customAttrs;\r\n\r\n\t\t// loop over existing custom properties, remove those that are not found among the new\r\n\t\t// ones and update those whose value has changed\r\n\t\tif (oldCustomAttrs)\r\n\t\t{\r\n\t\t\tfor( let name in oldCustomAttrs)\r\n\t\t\t{\r\n\t\t\t\tconst oldCustomAttr = oldCustomAttrs[name];\r\n\t\t\t\tconst newCustomAttr = newCustomAttrs ? newCustomAttrs[name] : undefined;\r\n\t\t\t\tif (!newCustomAttr)\r\n\t\t\t\t{\r\n\t\t\t\t\t// if there is no new property with the given name, remove the old property and\r\n\t\t\t\t\t// terminate its handler\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toldCustomAttr.handler.terminate( false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch( err)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconsole.error( `Error terminating handler for custom attribute '${name}': ${err.message}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// update the custom property and remember the new value\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toldCustomAttr.handler.update( newCustomAttr.val);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch( err)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconsole.error( `Error updating handler for custom attribute '${name}': ${err.message}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tnewCustomAttr.handler = oldCustomAttr.handler;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// loop over new custom properties and add those that are not found among the old ones\r\n\t\tif (newCustomAttrs)\r\n\t\t{\r\n\t\t\tfor( let name in newCustomAttrs)\r\n\t\t\t{\r\n\t\t\t\tif (oldCustomAttrs && (name in oldCustomAttrs))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tlet newCustomAttr = newCustomAttrs[name];\r\n\r\n\t\t\t\t// create custom property handler. If we cannot create the handler, remove the property\r\n\t\t\t\t// from our object.\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tnewCustomAttr.handler = new newCustomAttr.info.handlerClass( this, newCustomAttr.val, name);\r\n\t\t\t\t}\r\n\t\t\t\tcatch( err)\r\n\t\t\t\t{\r\n\t\t\t\t\tconsole.error( `Error creating handler for custom attribute '${name}': ${err.message}`);\r\n\t\t\t\t\tdelete newCustomAttrs[name];\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.customAttrs = newCustomAttrs;\r\n\t}\r\n\r\n\r\n\r\n\t// Node's key. The derived classes set it based on their respective content. A key\r\n\t// can be of any type.\r\n\tpublic key: any;\r\n\r\n\t// Optional UpdateStrategy object defining different aspects of node behavior during updates.\r\n\tpublic updateStrategy: mim.UpdateStrategy;\r\n\r\n\t// Properties that were passed to the element.\r\n\tprivate props: any;\r\n\r\n\t// Array of children objects.\r\n\tprivate children: any[];\r\n\r\n\t// Reference to the component that is specified as a \"ref\" property. Reference object is\r\n\t// set when analyzing properties in the constructor and during update. Reference value is\r\n\t// set during mount and unset during unmount. The ref property can be changed on update.\r\n\tprivate ref: mim.RefPropType<any>;\r\n\r\n\t// Object that serves as a map between attribute names and their current values.\r\n\tprivate attrs: { [name: string]: AttrRunTimeData };\r\n\r\n\t// Object that serves as a map between names of event listeners and their respective\r\n\t// parameters.\r\n\tprivate events: { [name: string]: EventRunTimeData };\r\n\r\n\t// Object that serves as a map between names of custom element properties and their respective\r\n\t// handler objects and values.\r\n\tprivate customAttrs: { [name: string]: CystomAttrRunTimeData };\r\n}\r\n\r\n\r\n\r\n// Type defining the information we keep about each regular attribute\r\ninterface AttrRunTimeData\r\n{\r\n\t// Information about this attribute - can be null\r\n\tinfo: AttrPropInfo;\r\n\r\n\t// Flag indicating whether this event should be used as Capturing (true) or Bubbling (false)\r\n\tval: any;\r\n};\r\n\r\n\r\n\r\n// Type defining the information we keep about each event listener\r\ninterface EventRunTimeData\r\n{\r\n\t// Information about this event - can be null\r\n\tinfo: EventPropInfo;\r\n\r\n\t// Original event callback passed as the value of the event property in JSX\r\n\torgFunc: mim.EventFuncType<any>;\r\n\r\n\t// Object that will be referenced by \"this\" within the invoked function\r\n\tthat?: any;\r\n\r\n\t// Flag indicating whether this event should be used as Capturing (true) or Bubbling (false)\r\n\tuseCapture?: boolean;\r\n\r\n\t// Wrapper function that we create and bind to our node and the original function. We need\r\n\t// this wrapper in order to catch exception in the callback and pass them on to an error\r\n\t// handling service. The wrapper is marked optional because it is created only if a new\r\n\t// event listener is added; that is, if during update, the event listener function is the\r\n\t// same, there is no need to create new wrapper because the old one will be used.\r\n\twrapper?:  mim.EventFuncType<Event>;\r\n};\r\n\r\n\r\n\r\n// Type defining the information we keep about each custom property.\r\ninterface CystomAttrRunTimeData\r\n{\r\n\t// Information about this custom attribute - cannot be null\r\n\tinfo: CustomAttrPropInfo;\r\n\r\n\t// Current value of the property\r\n\tval: any;\r\n\r\n\t// Handler object that knows to deal with the property values\r\n\thandler: mim.ICustomAttributeHandler<any>;\r\n};\r\n\r\n\r\n\r\n// Determines whether the given property value is of the type that is used for event handlers.\r\nfunction isEventValue( propVal: any): boolean\r\n{\r\n\treturn typeof propVal === \"function\" ||\r\n\t\tArray.isArray(propVal) && propVal.length > 0 && typeof propVal[0] === \"function\";\r\n}\r\n\r\n\r\n\r\n// Determines whether the given property value is of the type that is used for event handlers.\r\n// If yes, then returns EventRunTimeData object; otherwise, returns undefined.\r\nfunction getPropAsEventRunTimeData( info: EventPropInfo, propVal: any): EventRunTimeData\r\n{\r\n\tif (typeof propVal === \"function\")\r\n\t\treturn { info, orgFunc: propVal as mim.EventFuncType<any> };\r\n\telse if (Array.isArray(propVal))\r\n\t{\r\n\t\tif (propVal.length === 2)\r\n\t\t{\r\n\t\t\tif (typeof propVal[1] === \"boolean\")\r\n\t\t\t\treturn { info, orgFunc: propVal[0] as mim.EventFuncType<any>, useCapture: propVal[1] as boolean };\r\n\t\t\telse\r\n\t\t\t\treturn { info, orgFunc: propVal[0] as mim.EventFuncType<any>, that: propVal[1] };\r\n\t\t}\r\n\t\telse if (propVal.length === 3)\r\n\t\t\treturn { info, orgFunc: propVal[0] as mim.EventFuncType<any>, that: propVal[1], useCapture: propVal[2] as boolean };\r\n\t}\r\n\r\n\t// for all other type combinations the property is not treated as an event handler\r\n\treturn undefined;\r\n}\r\n\r\n\r\n\r\n","///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The SvgElmInfo type defines information that can be specified for an SVG element. This\r\n// information can be of the following types:\r\n//\t- string - actual name to use for the element. Some SVG elements have names that cannot be used\r\n//\t\tin JX directly (e.g. because of hyphen like in \"color-profile\"). In this case the string\r\n//\t\tvalue will be the actual element name to put into HTML document, while JSX will be using\r\n//\t\ta camel-formatted name (e.g. \"colorProfile\").\r\n//\t- boolean - flag indicating that the element is \"dual-purpose\"; that is, element with this\r\n//\t\tname can be used as either HTML or SVG element.\r\n//\t- tuple of two elements - string and boolean corresponding to the above items.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport type SvgElmInfo = boolean | string | [string, boolean];\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The SvgElms class contains properties with names used to define SVG elements in JSX. When\r\n// we need to create an element, we lookup the provided tag name and if we find it in this class\r\n// we use document.createElementNS with the proper SVG namespace string. Values of these properties\r\n// are SvgElmInfo values.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class SvgElms\r\n{\r\n\t// Namespace used to create SVG elements.\r\n\tpublic static namespace: string = \"http://www.w3.org/2000/svg\";\r\n\r\n\r\n\r\n\t// Registers information about the given SVG tag\r\n\tpublic static register( tagName: string, info: SvgElmInfo): void\r\n\t{\r\n\t\tSvgElms.infos[tagName] = info;\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the given tag name can be used as an SVG element name.\r\n\tpublic static isSvgElm( tagName: string): boolean\r\n\t{\r\n\t\treturn tagName in SvgElms.infos;\r\n\t}\r\n\r\n\r\n\r\n\t// Returns information object for the given tag name.\r\n\tpublic static getSvgElmInfo( tagName: string): SvgElmInfo | undefined\r\n\t{\r\n\t\treturn SvgElms.infos[tagName];\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the given information object has the \"dual-purpose\" flag set.\r\n\tpublic static isDualPurpose( info: SvgElmInfo): boolean\r\n\t{\r\n\t\tif (Array.isArray( info))\r\n\t\t\treturn (info as Array<any>).length > 1 ? (info as [string, boolean])[1] : false;\r\n\t\telse\r\n\t\t\treturn typeof info === \"string\" ? false : info as boolean;\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the given tag name is a \"dual-purpose\" element; that is can be either\r\n\t// HTML and SVG element.\r\n\tpublic static isTagDualPurpose( tagName: string): boolean\r\n\t{\r\n\t\tlet info: SvgElmInfo = SvgElms.infos[tagName];\r\n\t\treturn info ? SvgElms.isDualPurpose( info) : false;\r\n\t}\r\n\r\n\r\n\r\n\t// Returns the actual name to be used based on the information object and the tag name\r\n\tpublic static getElmName( info: SvgElmInfo, tagName: string): string | undefined\r\n\t{\r\n\t\tif (Array.isArray( info))\r\n\t\t\treturn (info as Array<any>).length > 0 ? (info as [string, boolean])[0] : tagName;\r\n\t\telse\r\n\t\t\treturn typeof info === \"string\" ? info as string : tagName;\r\n\t}\r\n\r\n\r\n\r\n\t// Returns the actual name to be used the given tag name\r\n\tpublic static getElmNameForTag( tagName: string): string\r\n\t{\r\n\t\tlet info: SvgElmInfo = SvgElms.infos[tagName];\r\n\t\treturn info ? SvgElms.getElmName( info, tagName) : tagName;\r\n\t}\r\n\r\n\r\n\r\n\t// Object that maps SVG element names to SvgElmInfo.\r\n\tprivate static infos: {[elmName:string]: SvgElmInfo} =\r\n\t{\r\n\t\tsvg: false,\r\n\r\n\t\ta: true,\r\n\t\tanimate: false,\r\n\t\tanimateMotion: false,\r\n\t\tanimateTransform: false,\r\n\r\n\t\tcircle: false,\r\n\t\tclipPath: false,\r\n\t\tcolorProfile: \"color-profile\",\r\n\r\n\t\tdefs: false,\r\n\t\tdesc: false,\r\n\t\tdiscard: false,\r\n\r\n\t\tellipse: false,\r\n\r\n\t\tfeBlend: false,\r\n\t\tfeColorMatrix: false,\r\n\t\tfeComponentTransfer: false,\r\n\t\tfeComposite: false,\r\n\t\tfeConvolveMatrix: false,\r\n\t\tfeDiffuseLighting: false,\r\n\t\tfeDisplacementMap: false,\r\n\t\tfeDistantLight: false,\r\n\t\tfeDropShadow: false,\r\n\t\tfeFlood: false,\r\n\t\tfeFuncA: false,\r\n\t\tfeFuncB: false,\r\n\t\tfeFuncG: false,\r\n\t\tfeFuncR: false,\r\n\t\tfeGaussianBlur: false,\r\n\t\tfeImage: false,\r\n\t\tfeMerge: false,\r\n\t\tfeMergeNode: false,\r\n\t\tfeMorphology: false,\r\n\t\tfeOffset: false,\r\n\t\tfePointLight: false,\r\n\t\tfeSpecularLighting: false,\r\n\t\tfeSpotLight: false,\r\n\t\tfeTile: false,\r\n\t\tfeTurbulence: false,\r\n\t\tfilter: false,\r\n\t\tforeignObject: false,\r\n\r\n\t\tg: false,\r\n\r\n\t\thatch: false,\r\n\t\thatchpath: false,\r\n\r\n\t\timage: false,\r\n\r\n\t\tline: false,\r\n\t\tlinearGradient: false,\r\n\r\n\t\tmarker: false,\r\n\t\tmask: false,\r\n\t\tmetadata: false,\r\n\t\tmpath: false,\r\n\r\n\t\tpath: false,\r\n\t\tpattern: false,\r\n\t\tpolygon: false,\r\n\t\tpolyline: false,\r\n\r\n\t\tradialGradient: false,\r\n\t\trect: false,\r\n\r\n\t\tscript: true,\r\n\t\tset: false,\r\n\t\tsolidcolor: false,\r\n\t\tstop: false,\r\n\t\tstyle: true,\r\n\t\tswitch: false,\r\n\t\tsymbol: false,\r\n\r\n\t\ttext: false,\r\n\t\ttextPath: false,\r\n\t\ttitle: true,\r\n\t\ttextSpan: false,\r\n\r\n\t\tuse: false,\r\n\r\n\t\tview: false,\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {DN, VN, VNUpdateDisp} from \"./VN\"\r\nimport {VNBase} from \"./VNBase\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n/**\r\n * Represents a text node.\r\n */\r\nexport class TextVN extends VNBase implements mim.ITextVN\r\n{\r\n\t// Text for a simple text node.\r\n\tpublic text: string;\r\n\r\n\t// Text DOM node\r\n\tpublic textNode: Text;\r\n\r\n\r\n\r\n\tconstructor( text: string)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis.type = mim.VNType.Text;\r\n\t\tthis.text = text;\r\n\t};\r\n\r\n\r\n\r\n/////////////////\r\n/////////////////////////////////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic get name(): string { return \"#text\"; }\r\n\r\n\t// Returns DOM node corresponding to the virtual node itself (if any) and not to any of its\r\n\t// sub-nodes.\r\n\tpublic get ownDN(): DN { return this.textNode; };\r\n\r\n\r\n\r\n\t// Creates and returns DOM node corresponding to this virtual node.\r\n\t// This method is part of the Commit phase.\r\n\tpublic mount(): DN\r\n\t{\r\n///////////////////\r\n///////////////////////////////////////////////////////////////////\r\n////////////\r\n\r\n\t\treturn this.textNode = document.createTextNode( this.text);\r\n\t}\r\n\r\n\r\n\r\n\t// Destroys DOM node corresponding to this virtual node.\r\n\t// This method is part of the Commit phase.\r\n\tpublic unmount(): void\r\n\t{\r\n\t\tthis.textNode = undefined;\r\n\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n\r\n\r\n\r\n\t// Prepares this node to be updated from the given node. This method is invoked only if update\r\n\t// happens as a result of rendering the parent nodes. The newVN parameter is guaranteed to\r\n\t// point to a VN of the same type as this node. The returned object indicates whether children\r\n\t// should be updated and whether the commitUpdate method should be called.\r\n\t// This method is part of the Render phase.\r\n\tpublic prepareUpdate( newVN: VN): VNUpdateDisp\r\n\t{\r\n\t\t// text nodes don't have sub-nodes\r\n\t\treturn VNUpdateDisp.getStockValue( this.text !== (newVN as TextVN).text, false);\r\n\t}\r\n\r\n\r\n\r\n\t// Commits updates made to this node to DOM.\r\n\tpublic commitUpdate( newVN: VN): void\r\n\t{\r\n\t\tthis.textNode.nodeValue = this.text = (newVN as TextVN).text;\r\n\r\n///////////////////\r\n/////////////////////////////////////////////////////////////////////\r\n////////////\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {updateNodeSync, requestNodeUpdate} from \"./Scheduler\"\r\nimport {DN} from \"./VN\"\r\nimport {VNBase} from \"./VNBase\"\r\nimport {RootErrorUI, RootWaitingUI} from \"./RootUI\"\r\n\r\n/////////////////\r\n/////////////////////////////////////////////\r\n//////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The RootVN class is used as a top-level virtual node for all rendered trees. RootVN serves\r\n// as an error boundary of last resort. When it catches an error that wasn't caught by any\r\n// descendand node, it displays a simple UI that shows the error and allows the user to restart.\r\n// RootVN also manages service publishers and subscribers.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class RootVN extends VNBase implements mim.IErrorHandlingService\r\n{\r\n\tpublic constructor( anchorDN: DN)\r\n\t{\r\n\t\tsuper();\r\n\t\t\r\n\t\tthis.type = mim.VNType.Root;\r\n\t\tthis.anchorDN = anchorDN;\r\n\t\tthis.depth = 0;\r\n\t\t// this.willMount();\r\n\t};\r\n\r\n\r\n\r\n//////////////////\r\n//////////////////////////////////////////////////////////////////////////\r\n///////////\r\n\r\n\t// String representation of the virtual node. This is used mostly for tracing and error\r\n\t// reporting. The name can change during the lifetime of the virtual node; for example,\r\n\t// it can reflect an \"id\" property of an element (if any).\r\n\tpublic get name(): string { return \"Root\"; }\r\n\r\n\r\n\r\n\t// Sets the content to be rendered under this root node and triggers update.\r\n\tpublic setContent( content: any, sync: boolean): void\r\n\t{\r\n\t\tthis.content = content;\r\n\r\n\t\tif (sync)\r\n\t\t\tupdateNodeSync( this);\r\n\t\telse\r\n\t\t\trequestNodeUpdate( this);\r\n\t}\r\n\r\n\r\n\r\n\t// Generates a chain of sub-nodes according to the current state. If the node doesn't have\r\n\t// sub-nodes, null should be returned.\r\n\tpublic render(): any\r\n\t{\r\n\t\tif (this.errorUI)\r\n\t\t\treturn this.errorUI;\r\n\t\telse if (this.waitingUI)\r\n\t\t\treturn this.waitingUI;\r\n\t\telse\r\n\t\t\treturn this.content;\r\n\t}\r\n\r\n\r\n\r\n\t// Creates internal stuctures of the virtual node so that it is ready to produce children.\r\n\t// This method is called right after the node has been constructed.\r\n\t// This method is part of the Render phase.\r\n\tpublic willMount(): void\r\n\t{\r\n\t\tthis.publishService( \"StdErrorHandling\", this);\r\n\t}\r\n\r\n\r\n\r\n\t// This method is called before the content of node and all its sub-nodes is removed from the\r\n\t// DOM tree.\r\n\t// This method is part of the render phase.\r\n\tpublic willUnmount(): void\r\n\t{\r\n\t\tthis.unpublishService( \"StdErrorHandling\");\r\n\t}\r\n\r\n\r\n\r\n\t// Determines whether the node supports handling of errors; that is, exception thrown during\r\n\t// rendering of the node itself and/or its sub-nodes.\r\n\tpublic supportsErrorHandling(): boolean\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\r\n\t// This method is called after an exception was thrown during rendering of the node itself\r\n\t// or its sub-nodes.\r\n\tpublic handleError( err: any, path: string[]): void\r\n\t{\r\n\t\tif (err instanceof Promise)\r\n\t\t{\r\n\t\t\tlet promise = err as Promise<any>;\r\n\t\t\tthis.thrownPromises.add( promise);\r\n\t\t\tpromise.then( () => { this.onPromiseFulfilled( promise); });\r\n\t\t\tpromise.catch( () => { this.onPromiseFulfilled( promise); });\r\n\t\t\tif (!this.waitingUI)\r\n\t\t\t\tthis.waitingUI = new RootWaitingUI();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.errorUI = new RootErrorUI( this, err, path);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Displays the content originally passed in the constructor.\r\n\tpublic restart(): void\r\n\t{\r\n\t\t// clear the error and request to be updated\r\n\t\tthis.errorUI = undefined;\r\n\t\trequestNodeUpdate( this);\r\n\t}\r\n\r\n\r\n\r\n\t// Informs that the given node has unsubscribed from a service with the given ID.\r\n\tpublic reportError( err: any, path: string[]): void\r\n\t{\r\n\t\tthis.handleError( err, path);\r\n\t\trequestNodeUpdate( this);\r\n\t}\r\n\r\n\r\n\r\n\t// Removes the fulfilled promise from our internal list and if the list is empty asks to\r\n\t// re-render\r\n\tprivate onPromiseFulfilled( promise: Promise<any>): void\r\n\t{\r\n\t\tthis.thrownPromises.delete( promise);\r\n\t\tif (this.thrownPromises.size === 0)\r\n\t\t{\r\n\t\t\tthis.waitingUI = null;\r\n\t\t\trequestNodeUpdate( this);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t// Content rendered under this root node.\r\n\tprivate content: any;\r\n\r\n\t// Component instance that is rendered when an exception was caught from descendand nodes.\r\n\tprivate errorUI: RootErrorUI;\r\n\r\n\t// Component instance that is rendered when an exception was caught from descendand nodes.\r\n\tprivate waitingUI: RootWaitingUI;\r\n\r\n\t// Set of promises thrown by descendant nodes and not yet fulfilled.\r\n\tprivate thrownPromises = new Set<Promise<any>>();\r\n}\r\n\r\n\r\n\r\nlet s_mimblAnchorPropName = \"__mimblAnchorPropName__\";\r\n\r\n\r\n\r\n// Renders the given content (usually a result of JSX expression or a component instance)\r\n// under the given HTML element in a synchronous way.\r\nexport function mountRootSync( content: any, anchorDN: DN): void\r\n{\r\n\tlet realAnchorDN: DN = anchorDN ? anchorDN : document.body;\r\n\r\n\t// check whether we already have root node remembered in the anchor element's well-known\r\n\t// property\r\n\tlet rootVN: RootVN = realAnchorDN[s_mimblAnchorPropName];\r\n\tif (!rootVN)\r\n\t{\r\n\t\t// create root node and remember it in the anchor element's well-known property\r\n\t\trootVN = new RootVN( realAnchorDN);\r\n\t\t(realAnchorDN as any)[s_mimblAnchorPropName] = rootVN;\r\n\t}\r\n\r\n\r\n\t// set content to the root node and trigger synchronous update\r\n\trootVN.setContent( content, true);\r\n}\r\n\r\n\r\n\r\n// Unmounts a root node that was created using mountRootSync.\r\nexport function unmountRootSync( anchorDN: DN): void\r\n{\r\n\tlet realAnchorDN: DN = anchorDN ? anchorDN : document.body;\r\n\tif (!realAnchorDN)\r\n\t\treturn;\r\n\r\n\t// get our root node from the anchor element's well-known property.\r\n\tlet rootVN: RootVN = realAnchorDN[s_mimblAnchorPropName];\r\n\tif (!rootVN)\r\n\t\treturn;\r\n\r\n\t// remove our root node from the anchor element's well-known property\r\n\tdelete realAnchorDN[s_mimblAnchorPropName];\r\n\r\n\trootVN.setContent( null, true);\r\n\trootVN.term();\r\n}\r\n\r\n\r\n\r\n// Renders the given content (usually a result of JSX expression or a component instance)\r\n// under the given HTML element.\r\nexport function mountRoot( content: any, anchorDN: DN): void\r\n{\r\n\tlet realAnchorDN: DN = anchorDN ? anchorDN : document.body;\r\n\r\n\t// check whether we already have root node remembered in the anchor element's well-known\r\n\t// property\r\n\tlet rootVN: RootVN = realAnchorDN[s_mimblAnchorPropName];\r\n\tif (!rootVN)\r\n\t{\r\n\t\t// create root node and remember it in the anchor element's well-known property\r\n\t\trootVN = new RootVN( realAnchorDN);\r\n\t\t(realAnchorDN as any)[s_mimblAnchorPropName] = rootVN;\r\n\t}\r\n\r\n\t// set content to the root node, which will trigger update\r\n\trootVN.setContent( content, false);\r\n}\r\n\r\n\r\n\r\n// Unmounts a root node that was created using mountRoot.\r\nexport function unmountRoot( anchorDN: DN): void\r\n{\r\n\tlet realAnchorDN: DN = anchorDN ? anchorDN : document.body;\r\n\tif (!realAnchorDN)\r\n\t\treturn;\r\n\r\n\t// get our root node from the anchor element's well-known property.\r\n\tlet rootVN: RootVN = realAnchorDN[s_mimblAnchorPropName];\r\n\tif (!rootVN)\r\n\t\treturn;\r\n\r\n\t// remove our root node from the anchor element's well-known property\r\n\tdelete realAnchorDN[s_mimblAnchorPropName];\r\n\r\n\t// destruct the root node (asynchronously)\r\n\trootVN.setContent( null, false);\r\n\trootVN.scheduleCall( () => rootVN.willUnmount() );\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {RootVN} from \"./RootVN\"\r\n\r\n\r\nexport class RootErrorUI extends mim.Component\r\n{\r\n\tprivate rootVN: RootVN;\r\n\tprivate err: any;\r\n\tprivate pathString: string;\r\n\r\n\tconstructor( rootVN: RootVN, err: any, path: string[])\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.rootVN = rootVN;\r\n\t\tthis.err = err;\r\n\t\tthis.pathString = path ? path.join( \" \\u2192 \") : \"\";\r\n\t}\r\n\r\n\tpublic render(): any\r\n\t{\r\n\t\treturn <div id=\"rootError\" style={{display:\"flex\", flexDirection:\"column\", alignItems: \"start\"}}>\r\n\t\t\t<div>{this.err.message}</div>\r\n\t\t\t<div>{this.pathString}</div>\r\n\t\t\t<hr style={{width:\"100%\"}}/>\r\n\t\t\t<button click={this.onRestart}>Restart</button>\r\n\t\t</div>\r\n\t}\r\n\r\n\tprivate onRestart = (): void =>\r\n\t{\r\n\t\tthis.rootVN.restart();\r\n\t};\r\n\r\n}\r\n\r\n\r\n\r\nexport class RootWaitingUI extends mim.Component\r\n{\r\n\tpublic render(): any\r\n\t{\r\n\t\treturn \"Loading ...\";\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"../api/mim\"\r\nimport {IEventSlot, EventSlot} from\"../utils/EventSlot\"\r\n\r\n\r\n\r\ndeclare module \"../api/mim\"\r\n{\r\n    export interface IServiceDefinitions\r\n\t{\r\n        LocalStyles: ILocalStyleService;\r\n    }\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The ILocalStyleService interface represents a service that is published by components that\r\n// define their local CSS styles; that is, components deriving from the ComponentWithLocalStyles\r\n// class. The interface allows retrieving CSS class and variable names decorated with the unique\r\n// ID, which avoids duplication of names between components of the same or different types.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface ILocalStyleService\r\n{\r\n\t// Returns the unique ID used to decorate CSS class and variable names to make them unique.\r\n\treadonly uniqueID: string;\r\n\r\n\t// Retrurns CSS class or variable name decorated with a unique ID.\r\n\tdecorateName( name: string): string;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The ComponentWithLocalStyles class is a base class for components that define local CSS styles.\r\n// When this component is mounted it creates a new <style> element (within the <head> element).\r\n// All class names and variable names defined within this style will have a unique ID added to\r\n// them in order to avoid duplication of names among other components (of the same or of different\r\n// type. This class also publishes a service implementing the ILocalStyleService\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport abstract class ComponentWithLocalStyles<TProps = {}, TChildren = any>\r\n\t\t\t\textends mim.Component<TProps,TChildren>\r\n\t\t\t\timplements ILocalStyleService\r\n{\r\n\tconstructor( props: TProps = null)\r\n\t{\r\n\t\tsuper( props);\r\n\r\n\t\tthis.m_uniqueID = (Math.floor( Math.random() * 1000000000)).toString();\r\n\t\tthis.rules = new Map<string,RuleInfo>();\r\n\t\tthis.ruleNames = [];\r\n\r\n\t\t// create <style> element in the <head>\r\n\t\tthis.styleElm = document.createElement( \"style\");\r\n\t\tthis.styleElm.id = this.m_uniqueID;\r\n\t\tdocument.head.appendChild( this.styleElm);\r\n\r\n\t\t//// WebKit hack :(\r\n\t\t//this.styleElm.appendChild(document.createTextNode(\"\"));\r\n\t}\r\n\r\n\r\n\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t// ILocalStyleService implementation.\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t// Returns the unique ID used to decorate CSS class and variable names to make them unique.\r\n\tpublic get uniqueID(): string { return this.m_uniqueID; }\r\n\r\n\t// Retrurns CSS class or variable name decorated with a unique ID.\r\n\tpublic decorateName( name: string): string\r\n\t{\r\n\t\treturn name + this.m_uniqueID;\r\n\t}\r\n\r\n\r\n\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t// Public interface.\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t// Creates style rule.\r\n\tpublic createStyleRule( name: string, selector?: string, props?: mim.StylePropType): IMCssStyleRule\r\n\t{\r\n\t\t// create dummy style rule\r\n\t\tlet info: RuleInfo = this.createDummyRule( name, \"dummy {}\");\r\n\t\tlet cssomRule: CSSStyleRule = info.cssomRule as CSSStyleRule;\r\n\r\n\t\t// create style rule object\r\n\t\tlet mcssStyleRule: MCssStyleRule = new MCssStyleRule( this.uniqueID, cssomRule);\r\n\t\tif (selector)\r\n\t\t\tmcssStyleRule.setSelector( selector);\r\n\t\tif (props)\r\n\t\t\tmcssStyleRule.setProperties( props);\r\n\r\n\t\tinfo.mcssRule = mcssStyleRule;\r\n\t\treturn mcssStyleRule;\r\n\t}\r\n\r\n\r\n\r\n\t// Returns a rule with the given name.\r\n\tpublic getRule( name: string): IMCssRule\r\n\t{\r\n\t\tlet info: RuleInfo = this.rules.get( name);\r\n\t\treturn info === undefined ? undefined : info.mcssRule;\r\n\t}\r\n\r\n\r\n\r\n\t// Removes a rule with the given name.\r\n\tpublic removeRule( name: string): void\r\n\t{\r\n\t}\r\n\r\n\r\n\r\n\tpublic willMount()\r\n\t{\r\n\t\tthis.vn.publishService( \"LocalStyles\", this);\r\n\t}\t\r\n\r\n\r\n\r\n\tpublic willUnmount()\r\n\t{\r\n\t\tthis.vn.unpublishService( \"LocalStyles\");\r\n\r\n\t\tthis.styleElm.remove();\r\n\t}\r\n\r\n\r\n\r\n\t// Creates style rule.\r\n\tprivate createDummyRule( name: string, ruleText: string): RuleInfo\r\n\t{\r\n\t\t// check if we already have a rule with this name\r\n\t\tlet info: RuleInfo = this.rules.get( name);\r\n\t\tif (info !== undefined)\r\n\t\t\tthis.removeRule( name);\r\n\r\n\t\t// the new rule will becomes the last in the array of rules\r\n\t\tlet index = this.ruleNames.length;\r\n\r\n\t\t// create dummy style rule\r\n\t\tlet sheet: CSSStyleSheet = this.styleElm.sheet as CSSStyleSheet;\r\n\t\tsheet.insertRule( ruleText, index);\r\n\t\tlet cssomRule: CSSRule = sheet.rules[index];\r\n\r\n\t\t// add the rule to our internal structures\r\n\t\tthis.ruleNames.push( name);\r\n\t\tinfo = { mcssRule: null, cssomRule, index };\r\n\t\tthis.rules.set( name, info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\r\n\r\n\t// Unique ID that is used to decorate CSS class and variable names defined by the component.\r\n\tprivate m_uniqueID: string;\r\n\r\n\t// Style element DOM object. Is defined only when the component is mounted.\r\n\tprivate styleElm: HTMLStyleElement;\r\n\r\n\t// Map of rules by their names.\r\n\tprivate rules: Map<string,RuleInfo>;\r\n\r\n\t// Array of rule names. This is needed to adjust indexes of rules after a rule is removed.\r\n\tprivate ruleNames: string[];\r\n\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Helper type that keeps information about a CSS rule added to ComponentWithLocalStyles.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\ntype RuleInfo = { mcssRule: IMCssRule, cssomRule: CSSRule, index: number };\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The IMCssRule interface represents a CSS rule.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface IMCssRule\r\n{\r\n\t// Unique ID used in class and variable names\r\n\treadonly uniqueID: string;\r\n\r\n\t// CSSOM rule\r\n\treadonly cssomRule: CSSRule;\r\n\r\n\t// Appends unique ID to the given name.\r\n\tdecorate( name: string): string;\r\n\r\n\t// Replaces the marker \"(*)\" in the given name with the unique ID\r\n\treplace( name: string): string;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The MCssRule class is a base class for objects represented different types of CSS rules that\r\n// are created by the ComponentWithLocalStyles component. This object simply keeps the unique\r\n// ID that should be used by derived classes when creating class and variable names so that they\r\n// are globally unique.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass MCssRuleBase<T extends CSSRule> implements IMCssRule\r\n{\r\n\tconstructor( uniqueID: string, cssomRule: T)\r\n\t{\r\n\t\tthis.uniqueID = uniqueID;\r\n\t\tthis.cssomRule = cssomRule;\r\n\t}\r\n\r\n\r\n\r\n\t// Appends unique ID to the given name.\r\n\tpublic decorate( name: string): string\r\n\t{\r\n\t\treturn name + this.uniqueID;\r\n\t}\r\n\r\n\r\n\r\n\t// Replaces the marker \"(*)\" in the given name with the unique ID\r\n\tpublic replace( name: string): string\r\n\t{\r\n\t\treturn name.replace( \"(*)\", this.uniqueID);\r\n\t}\r\n\r\n\r\n\r\n\t// Unique ID used in class and variable names\r\n\tpublic uniqueID: string;\r\n\r\n\t// CSSOM rule\r\n\tpublic cssomRule: T;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The IMCssStyleRule interface represents a style rule.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport interface IMCssStyleRule\r\n{\r\n\t// Sets the rule selector. The string can contain the (*) marker, which will be substituted\r\n\t// with the unique ID.\r\n\tsetSelector( selector: string);\r\n\r\n\t// Sets value for a style property. Both property name and property value can use the\r\n\t// (*) marker, which will be substituted with the unique ID.\r\n\tsetProperty( propName: string, propVal: string, important?: boolean): void;\r\n\r\n\t// Sets several style properties. Both property names and property values can use the\r\n\t// (*) marker, which will be substituted with the unique ID.\r\n\tsetProperties( props: mim.StylePropType): void;\r\n\r\n\t// Sets value for a style property. Property name can use the (*) marker, which will be\r\n\t// substituted with the unique ID.\r\n\tremoveProperty( propName: string): void;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// The MCssStyleRule interface represents a style rule that contains a selector and a set of\r\n// style property name-value pairs.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass MCssStyleRule extends MCssRuleBase<CSSStyleRule> implements IMCssStyleRule\r\n{\r\n\tconstructor( uniqueID: string, cssomRule: CSSStyleRule)\r\n\t{\r\n\t\tsuper( uniqueID, cssomRule);\r\n\t}\r\n\r\n\r\n\r\n\t// Sets the rule selector. The string can contain the (*) marker, which will be substituted\r\n\t// with the unique ID.\r\n\tpublic setSelector( selector: string)\r\n\t{\r\n\t\tthis.cssomRule.selectorText = this.replace( selector);\r\n\t}\r\n\r\n\r\n\r\n\t// Sets value for a style property. Both property name and property value can use the\r\n\t// (*) marker, which will be substituted with the unique ID.\r\n\tpublic setProperty( propName: string, propVal: string, important?: boolean): void\r\n\t{\r\n\t\tthis.cssomRule.style.setProperty( this.replace( propName), this.replace( propVal),\r\n\t\t\t\t\t\timportant? \"important\" : undefined);\r\n\t}\r\n\r\n\r\n\r\n\t// Sets several style properties. Both property names and property values can use the\r\n\t// (*) marker, which will be substituted with the unique ID.\r\n\tpublic setProperties( props: mim.StylePropType): void\r\n\t{\r\n\t\tif (!props)\r\n\t\t\treturn;\r\n\r\n\t\tfor( let propName in props)\r\n\t\t\tthis.cssomRule.style[this.replace( propName)] = this.replace( props[propName]);\r\n\t}\r\n\r\n\r\n\r\n\t// Sets value for a style property. Property name can use the (*) marker, which will be\r\n\t// substituted with the unique ID.\r\n\tpublic removeProperty( propName: string): void\r\n\t{\r\n\t\tthis.cssomRule.style.removeProperty( this.replace( propName));\r\n\t}\r\n}\r\n\r\n\r\n\r\n","import * as mim from \"mimbl\"\r\nimport {IMainContainer} from \"./Row\"\r\nimport {Store} from \"./Store\"\r\nimport {TBody} from\"./TBody\"\r\n\r\n\r\n// var startTime;\r\n// var lastMeasure;\r\n// var startMeasure = function(name) {\r\n//     //console.timeStamp(name);\r\n//     startTime = performance.now();\r\n//     lastMeasure = name;\r\n// }\r\n// var stopMeasure = function() {\r\n//     var last = lastMeasure;\r\n//     if (lastMeasure) {\r\n//         window.setTimeout(function () {\r\n//             lastMeasure = null;\r\n//             var stop = performance.now();\r\n//             var duration = 0;\r\n//             console.log(last+\" took \"+(stop-startTime));\r\n//         }, 0);\r\n//     }\r\n// }\r\n\r\nexport class Main extends mim.Component implements IMainContainer\r\n{\r\n    store: Store;\r\n    tbody: TBody;\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this.store = new Store();        \r\n        this.tbody = new TBody( this);\r\n\r\n        (window as any).app = this;\r\n    }\r\n\r\n    // schedulePrintDuration() {\r\n    //     this.callMe( () => stopMeasure(), false);\r\n    // }\r\n\r\n    run()\r\n    {\r\n        // startMeasure(\"run\");\r\n        this.tbody.run();\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    add()\r\n    {\r\n        // startMeasure(\"add\");\r\n        this.tbody.add();\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    update()\r\n    {\r\n        // startMeasure(\"update\");\r\n        this.tbody.update();\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    runLots()\r\n    {\r\n        // startMeasure(\"runLots\");\r\n        this.tbody.runLots();\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    clear()\r\n    {\r\n        // startMeasure(\"clear\");\r\n        this.tbody.clear();\r\n        this.tbody = new TBody( this);\r\n        this.updateMe();\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    swapRows()\r\n    {\r\n        // startMeasure(\"swapRows\");\r\n        this.tbody.swapRows();\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    onSelectRowClicked( row)\r\n    {\r\n        // startMeasure(\"select\");\r\n        this.tbody.onSelectRowClicked(row);\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    onDeleteRowClicked( row)\r\n    {\r\n        // startMeasure(\"delete\");\r\n        this.tbody.onDeleteRowClicked(row);\r\n        // this.schedulePrintDuration();\r\n    }\r\n    \r\n    render()\r\n    {\r\n        return (<div class=\"container\">\r\n            <div class=\"jumbotron\">\r\n                <div class=\"row\">\r\n                    <div class=\"col-md-6\">\r\n                        <h1>Mimbl (non-keyed)</h1>\r\n                    </div>\r\n                    <div class=\"col-md-6\">\r\n                        <div class=\"row\">\r\n                            <div class=\"col-sm-6 smallpad\">\r\n                                <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"run\" click={this.run}>Create 1,000 rows</button>\r\n                            </div>\r\n                            <div class=\"col-sm-6 smallpad\">\r\n                                <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"runlots\" click={this.runLots}>Create 10,000 rows</button>\r\n                            </div>\r\n                            <div class=\"col-sm-6 smallpad\">\r\n                                <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"add\" click={this.add}>Append 1,000 rows</button>\r\n                            </div>\r\n                            <div class=\"col-sm-6 smallpad\">\r\n                                <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"update\" click={this.update}>Update every 10th row</button>\r\n                            </div>\r\n                            <div class=\"col-sm-6 smallpad\">\r\n                                <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"clear\" click={this.clear}>Clear</button>\r\n                            </div>\r\n                            <div class=\"col-sm-6 smallpad\">\r\n                                <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"swaprows\" click={this.swapRows}>Swap Rows</button>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <table class=\"table table-hover table-striped test-data\" updateStrategy={{allowKeyedNodeRecycling:false}}>\r\n                {this.tbody}\r\n            </table>\r\n            <span class=\"preloadicon glyphicon glyphicon-remove\" aria-hidden=\"true\"></span>\r\n        </div>);\r\n    }\r\n}\r\n\r\nmim.mount( <Main/>, document.getElementById('main'));","'use strict';\r\n\r\nfunction _random(max) {\r\n    return Math.round(Math.random()*1000)%max;\r\n}\r\n\r\nexport class Store {\r\n    constructor() {\r\n        this.data = [];\r\n        this.selected = undefined;\r\n        this.id = 1;\r\n\t}\r\n    buildData(count = 1000) {\r\n        var adjectives = [\"pretty\", \"large\", \"big\", \"small\", \"tall\", \"short\", \"long\", \"handsome\", \"plain\", \"quaint\", \"clean\", \"elegant\", \"easy\", \"angry\", \"crazy\", \"helpful\", \"mushy\", \"odd\", \"unsightly\", \"adorable\", \"important\", \"inexpensive\", \"cheap\", \"expensive\", \"fancy\"];\r\n        var colours = [\"red\", \"yellow\", \"blue\", \"green\", \"pink\", \"brown\", \"purple\", \"brown\", \"white\", \"black\", \"orange\"];\r\n        var nouns = [\"table\", \"chair\", \"house\", \"bbq\", \"desk\", \"car\", \"pony\", \"cookie\", \"sandwich\", \"burger\", \"pizza\", \"mouse\", \"keyboard\"];\r\n        var data = [];\r\n        for (var i = 0; i < count; i++)\r\n            data.push({id: this.id++, label: adjectives[_random(adjectives.length)] + \" \" + colours[_random(colours.length)] + \" \" + nouns[_random(nouns.length)] });\r\n        return data;\r\n    }\r\n    updateData(mod = 10) {\r\n        for (let i=0;i<this.data.length;i+=mod) {\r\n        \tthis.data[i] = Object.assign({}, this.data[i], {label: this.data[i].label + ' !!!'});\r\n        }\r\n    }\r\n    delete(id) {\r\n        var idx = this.data.findIndex(d => d.id === id);\r\n        this.data.splice(idx, 1);\r\n        if (this.selected === id)\r\n            this.selected = undefined;\r\n    }\r\n    deleteByIndex(index) {\r\n        this.data.splice(index, 1);\r\n    }\r\n    run() {\r\n        this.data = this.buildData();\r\n        this.selected = undefined;\r\n    }\r\n    add() {\r\n        var newData = this.buildData(1000);\r\n        this.data = this.data.concat(newData);\r\n        return newData;\r\n    }\r\n    update() {\r\n        this.updateData();\r\n    }\r\n    select(id) {\r\n        this.selected = id;\r\n    }\r\n    runLots() {\r\n        this.data = this.buildData(10000);\r\n        this.selected = undefined;\r\n    }\r\n    clear() {\r\n        this.data = [];\r\n        this.selected = undefined;\r\n    }\r\n    swapRows( n, m) {\r\n    \tif(this.data.length > n && this.data.length > m) {\r\n    \t\tvar a = this.data[n];\r\n    \t\tthis.data[n] = this.data[m];\r\n    \t\tthis.data[m] = a;\r\n    \t}\r\n    }\r\n}","import * as mim from \"mimbl\"\r\nimport {Row, IMainContainer} from \"./Row\"\r\nimport {Store} from \"./Store\"\r\n\r\nexport class TBody extends mim.Component\r\n{\r\n    main: IMainContainer;\r\n    store: Store;\r\n\trows: Row[];\r\n    selectedRow: Row;\r\n\r\n    constructor( main)\r\n    {\r\n        super();\r\n\r\n        this.main = main;\r\n        this.store = main.store;\r\n        this.rows = [];\r\n    }\r\n\r\n    run() {\r\n        this.store.run();\r\n        this.selectedRow = undefined;\r\n\t\tthis.rows = this.store.data.map( item => new Row( this.main, item.id, item.label));\r\n        this.updateMe();\r\n    }\r\n    \r\n    add() {\r\n        this.store.add().forEach( item => this.rows.push( new Row( this.main, item.id, item.label)));\r\n        this.updateMe();\r\n    }\r\n    \r\n    update() {\r\n        this.store.update();\r\n        this.store.data.forEach( (item, i) => this.rows[i].setItem( item.label, this.store.selected));\r\n    }\r\n    \r\n    runLots() {\r\n        this.store.runLots();\r\n        this.selectedRow = undefined;\r\n\t\tthis.rows = this.store.data.map( item => new Row( this.main, item.id, item.label));\r\n        this.updateMe();\r\n    }\r\n    \r\n    clear() {\r\n        this.store.clear();\r\n        this.selectedRow = undefined;\r\n        this.rows = [];\r\n    }\r\n    \r\n    swapRows() {\r\n\t\tif (this.rows.length > 998)\r\n\t\t{\r\n            this.store.swapRows( 1, 998);\r\n\t\t\tlet tempRow = this.rows[1];\r\n\t\t\tthis.rows[1] = this.rows[998];\r\n\t\t\tthis.rows[998] = tempRow;\r\n            this.updateMe();\r\n\t\t}\r\n    }\r\n    \r\n    onSelectRowClicked( row: Row): void\r\n    {\r\n        this.store.select( row.id);\r\n        if (this.selectedRow && this.selectedRow !== row)\r\n            this.selectedRow.select( false);\r\n\r\n        this.selectedRow = row;\r\n    }\r\n    \r\n    onDeleteRowClicked(row: Row): void\r\n    {\r\n        this.store.delete( row.id);\r\n        let index = this.rows.indexOf( row);\r\n        this.rows.splice( index, 1);\r\n\r\n        if (this.selectedRow === row)\r\n            this.selectedRow = undefined;\r\n\r\n        this.updateMe();\r\n    }\r\n    \r\n    render()\r\n    {\r\n        return <tbody>\r\n            {this.rows}\r\n        </tbody>;\r\n    }\r\n}\r\n\r\n","import * as mim from \"mimbl\"\r\n\r\n\r\n\r\nexport interface IMainContainer\r\n{\r\n    onSelectRowClicked( row: Row): void;\r\n    onDeleteRowClicked( row: Row): void;\r\n}\r\n\r\n\r\n\r\nexport class Row extends mim.Component\r\n{\r\n\tmain: IMainContainer;\r\n\r\n\tid: number;\r\n\t@mim.updatable label: string;\r\n\t@mim.updatable selected: boolean;\r\n\r\n\tconstructor( main: IMainContainer, id: number, label: string)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.main = main;\r\n\t\tthis.id = id;\r\n\t\tthis.label = label;\r\n\t\tthis.selected = false;\r\n\t}\r\n\r\n\tsetItem( newLabel: string, newSelectedID: number)\r\n\t{\r\n\t\t// let newSelected = this.id === newSelectedID;\r\n\r\n\t\t// if (newLabel !== this.label || this.selected !== newSelected)\r\n\t\t// \tthis.updateMe();\r\n\r\n\t\tthis.label = newLabel;\r\n\t\tthis.selected = this.id === newSelectedID;\r\n\t}\r\n\r\n\tselect( selected: boolean)\r\n\t{\r\n\t\t// if (this.selected !== selected)\r\n\t\t// \tthis.updateMe();\r\n\r\n\t\tthis.selected = selected;\r\n\t}\r\n\r\n\tonDeleteClicked()\r\n\t{\r\n\t\tthis.main.onDeleteRowClicked( this);\r\n\t}\r\n\r\n\tonSelectClicked()\r\n\t{\r\n\t\tif (this.selected)\r\n\t\t\treturn;\r\n\r\n\t\tthis.selected = true;\r\n\t\tthis.main.onSelectRowClicked( this);\r\n\t\t// this.updateMe();\r\n\t}\r\n\r\n\trender()\r\n\t{\r\n\t\treturn <tr class={this.selected ? \"danger\" : undefined}>\r\n\t\t\t<td class=\"col-md-1\">{this.id}</td>\r\n\t\t\t<td class=\"col-md-4\"><a click={this.onSelectClicked}>{this.label}</a></td>\r\n\t\t\t<td class=\"col-md-1\"><a click={this.onDeleteClicked}><span class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></span></a></td>\r\n\t\t\t<td class=\"col-md-6\"></td>\r\n\t\t</tr>;\r\n\t}\r\n}\r\n\r\n"],"sourceRoot":""}