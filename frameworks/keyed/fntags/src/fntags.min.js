export const isNode=e=>e instanceof Node;export const fnstate=(e,t)=>{let n={currentValue:e,observers:[],bindContexts:[],mapKey:t,state(e){if(0===arguments.length)return n.currentValue;n.currentValue=e;for(let t of n.observers)t(e);return e}};return n.state.bindValues=(e,t,r)=>doBindValues(n,e,t,r),n.state.bindAs=(e,t)=>doBindAs(n,e,t),n.state.select=e=>doSelect(n,e),n.state.isFnState=!0,n.state.patch=e=>n.state(Object.assign(n.currentValue,e)),n.state.subscribe=e=>n.observers.push(e),n.state.reset=t=>doReset(n,t,e),n.state};function doReset(e,t,n){e.observers=[],t&&(e.currentValue=n)}let deselectEvent=new Event("deselect"),selectEvent=new Event("select");function doSelect(e,t){for(let n of e.bindContexts)n.selected&&n.boundElementByKey[n.selected]&&n.boundElementByKey[n.selected].dispatchEvent(deselectEvent),n.selected=t,n.boundElementByKey[t]&&n.boundElementByKey[t].dispatchEvent(selectEvent)}function doBindValues(e,t,n,r){if(!(t=renderNode(t)))throw new Error("You must provide a parent element to bind the children to. aka Need Bukkit.");if("function"!=typeof n&&!r)throw new Error("You must pass an update function when passing a non function element");return e.mapKey||(console.warn("Using value index as key, may not work correctly when moving items..."),e.mapKey=(e,t)=>t),Array.isArray(e.currentValue)?(e.currentValue=e.currentValue.map(fnstate),e.bindContexts.push({element:n,update:r,parent:t}),e.state.subscribe((()=>{Array.isArray(e.currentValue)?reconcile(e):(console.warn("A state used with bindValues was updated to a non array value. This will be converted to an array of 1 and the state will be updated."),setTimeout((()=>e.state([e.currentValue])),1))})),reconcile(e),t):e.state.bindAs(n,r)}function doBindAs(e,t,n){if("function"!=typeof t&&!n)throw new Error("You must pass an update function when passing a non function element");if(n){let r=renderNode(evaluateElement(t,e.currentValue));return e.state.subscribe((()=>n(r))),r}return replaceOnUpdate(e,(()=>t(e.currentValue)),0)}function replaceOnUpdate(e,t,n){let r=setKey(e,renderNode(t()),n);return e.state.subscribe((function(){let o=setKey(e,renderNode(t()),n);o&&(o.key&&o.key===r.key||(r.replaceWith(o),r=o))})),r}function reconcile(e){for(let t of e.bindContexts)t.boundElementByKey||(t.boundElementByKey={}),arrangeElements(e,t)}function setKey(e,t,n){return!t.key&&e.mapKey&&(t.key=keyMapper(e.mapKey,e.currentValue,n)),t}function keyMapper(e,t,n){return"object"!=typeof t?t:e?e(t,n):n}function arrangeElements(e,t){if(0===e.currentValue.length)return t.parent.textContent="",void(t.boundElementByKey={});let n=Object.keys(t.boundElementByKey).reduce(((e,t)=>(e[t]=!0)&&e),{}),r=null,o=t.parent,s={};for(let a=e.currentValue.length-1;a>=0;a--){let l=e.currentValue[a];l&&l.isFnState||(l=e.currentValue[a]=fnstate(l));let u=keyMapper(e.mapKey,l(),a);if(s[u])throw new Error("Duplicate keys in a bound array are not allowed.");s[u]=!0;let i=t.boundElementByKey[u],c=!1;i||(c=!0,i=t.boundElementByKey[u]=renderNode(evaluateElement(t.element,l)),i.key=u),r?r.previousSibling?r.previousSibling.key!==i.key&&(c?r.insertAdjacentElement("beforeBegin",i):r.previousSibling.replaceWith(i)):r.insertAdjacentElement("beforeBegin",i):o.lastChild&&o.lastChild.key===i.key||o.append(i),r=i,delete n[u]}for(let r of Object.keys(n))e.selected===r&&(e.selected=null),t.boundElementByKey[r].remove(),delete t.boundElementByKey[r]}const evaluateElement=(e,t)=>"function"==typeof e?e(t):e;export const renderNode=e=>{if("object"==typeof e&&void 0===e.then)return e;if(e&&"function"==typeof e.then){const e=marker();return e.then((t=>e.replaceWith(renderNode(t)))).catch((e=>console.error("Caught failed node promise.",e))),e}return document.createTextNode(e+"")};export const h=(e,...t)=>{let n=document.createElement(e);if(isAttrs(t[0])){let e=t.shift();for(let t in e){let r=e[t];if("style"===t&&"object"==typeof r)for(let e in r){let t=r[e].toString().match(/(.*)\W+!important\W*$/);t?n.style.setProperty(e,t[1],"important"):n.style.setProperty(e,r[e])}else"value"===t||"string"==typeof r?n.setAttribute(t,r):t.startsWith("on")&&"function"==typeof r?n.addEventListener(t.substring(2),r):n[t]=r}}for(let e of t)if(Array.isArray(e))for(let t of e)n.append(renderNode(t));else n.append(renderNode(e));return n};export const isAttrs=e=>e&&"object"==typeof e&&!Array.isArray(e)&&!(e instanceof Node);export const getAttrs=e=>isAttrs(e[0])?e[0]:{};const marker=e=>h("div",Object.assign(e||{},{style:"display:none"}));